<!DOCTYPE html>
<html lang="en">
<head>

<title>Elliott 903 Algol Translator</title>

<style>
.red {
	color: red
	}

.ul {
  	text-decoration-line: underline;
  	}

table, th, td {
  	border:1px solid black;
  	border-collapse: collapse;
  	margin-left:auto;
  	margin-right:auto;
	}

th, td {
	vertical-align: top;
  	padding-left:  15px;
  	padding-right: 15px;
  	padding-left:   10px;
  	padding-bottom  10px;
	}

.noborder {
	border-style:none;
	}

.margin0t {
	margin-left: -0.5em
	}

.margin1 {
	margin-left: 2.5em;
	}

.margin1t {
	margin-left: 1.75em;
	}

.margin2 {
	margin-left: 5em;
	}

.margin2t {
	margin-left: 4.15em;
	}

.margin3 {
	margin-left: 7.5em;
	}

.margin3t {
	margin-left: 6.25em;
	}

.margin4 {
	margin-left: 10em;
	}

.margin4t {
	margin-left: 7em;
	}

.right {
	text-align: right;
	}

.center {
	text-align: center;
	}

.middle {
	vertical-align: middle;
	}

.indent {
	text-indent: 2.5em;
	}

.left {
	margin-left: 0;
	}

.noleftborder {
	border-left: none;
	}

.norightborder {
	border-right: none;
	}

.notopborder {
	border-top: none;
	}

.nobottomborder {
	border-bottom: none;
	}

.courier {
	font-family: 'Courier New';
	font-size: 10pt;
	}

</style>

</head>

<body style="margin-left:2cm;width:16.5cm" class="courier">

<p class="center red">
	<u>ELLIOTT ALGOL TRANSLATOR</u>
</p>

<p class="indent red">
	This document is a lightly edited transcription of a type-written original
	document describing the Elliott 903 Algol Translator program.  References to
	global variables in the text are hyperlinked the definition of that
	identifier in the document. (Global identifiers are used to name translator
	state variables and principal translator subroutines.)
</p>

<p class="indent red">
	The descriptions of each subroutine are annotated with a "flowchart" link
	and a "code" link.  The flowchart link transfers to a scan of the hand drawn
	flowchart that accompanied the description document.  The code link
	transfers to the declaration of the label in the source code.  The source
	code is also in HTML and in each place where a global variable is referenced
	 in the source, it is coded as a hyperlink to the place where the identifier
	 is located.
</p>

<p class="indent red">
	To show where page breaks occur in the original document, page links are
	included 	in this document in the form [-PAGE nn-].  Clicking on these
	links transfers to a scanned image of the page from the original document.
</p>

<p class="indent red">
	The source code also includes "flowchart" links for global subroutine
	identifiers and also "description" links that transfer to a scan of the
	pages in the original document describing the identifier.
</p>

<p class="indent red">
	To understand the Elliott 903 Algol translator start reading this document
	linearly 	from the beginning, following the top down flow of the original
	document.  Follow	hyperlinks to refer to the definition of unfamiliar
	identifiers and the back button to 	return. For global subroutines use code
	links to see the corresponding source code 	and flowchart links to
	understand the logic of the code.
</p>

<p class="indent red">
	The original description can be viewed in its entirety here:
	[<a href="file:../../Elliott 903 ALGOL Translator.pdf">link</a>]
</p>

<p class="indent red">
	The source code can be viewed here in HTML form with hot links:
	[<a href="file:Translator_source.htm">link</a>]
</p>

<p class="indent red">
	The original flowcharts can be viewed in their entirety here:
	[<a href="file:../../Elliott 903 ALGOL Translator Flowcharts.pdf">link</a>]
</p>

<p class="indent red">
	To see how to build the Elliott Algol system using
	<a href="https://github.com/andrewjherbert/Elliott-900-simulator">
	my 903 emulator</a> look at this file: [<a href="https://andrewjherbert.github.io/Elliott-900-software-archive/ARCHIVE/SCRIPTS/903ALGOL/BUILD_ALG2PASS(ISS6).DAT">link</a>]

<p class="indent red">
	N.B. Additional explanatory text, like this, that did not appear in the
	original document is coloured red.
</p>

<p class="indent red">
	The main body of the description of the translator starts here
	<a href="#INTRODUCTION">(Introduction)</a>. The initial pages are notes
	about how to assemble the translator source.)
</p>

<p class="red">
	Andrew Herbert April 2023
</p>

<br><br><hr><br><br>

<p><a href="Description Pages/page0.jpg">[PAGE i]</a></p>

<p class="ul center">ELLIOTT 903 ALGOL</p>

<p class="ul center">Translator store map. December 1966</p>

<table class="noborder">
	<tr>
		<td class="noborder right">8 - 5969</td>
		<td class="noborder">Translator and constants</td>
	</tr>
	<tr>
		<td class="noborder righ"t>5970 - 5999</td>
		<td class="noborder">Patch space</td>
	</tr>
	<tr></tr>
		<td class="noborder right">6000 - 6014</td>
		<td class="noborder">Input buffer INBUF (INBUF-1 is referenced)</td>
	</tr>
	<tr>
		<td class="noborder right">6015 - 6056</td>
		<td class="noborder">Stack See location (SP + 1)</td>
	</tr>
	<tr>
		<td class="noborder right">6057 - 6146
		</td>
		<td class="noborder">CODL growing upwards towards 8191</td>
	</tr>
	<tr>
		<td class="noborder right">6147 - 7794
		</td>
		<td class="noborder">Namelist growing downwards towards 0</td>
	</tr>
	<tr>
		<td class="noborder right">7995 - 7998
		</td>
		<td class="noborder">Built in names</td>
	</tr>
	<tr>
		<td class="noborder right">7999</td>
		<td class="noborder"">Spare</td>
	</tr>
	<tr>
		<td class="noborder right">8000 - 8179
		</td>
		<td class="noborder">Spare</td>
	</tr>
</table>
</p><p>
D. Hunter.
</p>

<p><a href="Description Pages/page1.jpg">[PAGE ii]</a></p>

<p class="ul center">ELLIOTT 903 ALGOL
</p>
<p class="ul center">
How to add names to the built in namelist December 1966
</p>

<p class="ul">
	1.&nbsp;&nbsp;General
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">1.1</td>
		<td class="noborder">
			It does not matter where the name is added to the
			list which is in alphabetical order except that
			CHECKB, CHECKI and CHECKR are at the end; it was
			at one time necessary for them to be at the end,
			but this is no longer so.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">1.2</td>
		<td class="noborder">
			If the namelist is altered in length the following
			changes must be made in the Translator on the
			assumption that the last name continues to occupy
			locations 7995 - 7998 inclusive.
			<br><br>
		</td>
	<tr>
		<td class="noborder">1.2.1</td>
		<td class="noborder">
			The SIR directive at the front of the namelist
			must be reduced appropriately, e.g. by 8 to
			&uarr;+7787, for one extra procedure name with a
			few parameters.
			<br><br>
		</td>
	<tr>
		<td class="noborder">1.2.2</td>
		<td class="noborder">
			At START + 9 the instruction 2 +7795 must be
			changed to, e.g. 2 +7787, for one extra procedure
			name. If this is not done the name will be
			cleared to zero at the start.
			<br><br>
		<td class="noborder">
	<tr>
		<td class="noborder">1.2.3</td>
		<td class="noborder">
			At START + 45 the instruction 4 -200 must be
			changed to, e.g. 4 -208 for one extra procedure
			name. If this is not done the name will not
			have its "used" bit set to zero at the start.
		</td>
	</tr>
</table>

<p class="ul">2.&nbsp;&nbsp;Structure of a namelist entry</p>

<p class="indent">
	Only procedure names are considered here. If a procedure
	has parameters then extra space is required for their codewords
	e.g. the procedures P, CAT and FRED with 0, 1 and 5 parameters:-
</p>
<table class="noborder margin0t">
<tr>
	<td  class="noborder"><u>Without parameters</u>&nbsp;&nbsp;&nbsp;&nbsp;
	</td>
	<td  class="noborder"><u>One parameter</u>&nbsp;&nbsp;&nbsp;&nbsp;</td>
	<td  class="noborder"><u>Five parameters</u>&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
	<td  class="noborder"></td>
	<td  class="noborder"></td>
	<td  class="noborder">+0</td>
	<td  class="noborder">)</td>
</tr>
<tr>
	<td  class="noborder"></td>
	<td  class="noborder"></td>
	<td  class="noborder">+0</td>
	<td  class="noborder">)</td>
</tr>
<tr>
	<td  class="noborder"></td>
	<td  class="noborder"></td>
	<td  class="noborder">+0</td>
	<td  class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;codewords</td>
</tr>
<tr>
	<td  class="noborder"></td>
	<td  class="noborder"></td>
	<td  class="noborder">p 5</td>
	<td  class="noborder">)</td>
</tr>
<tr>
	<td  class="noborder"></td>
	<td  class="noborder">+0</trd>
	<td  class="noborder">p 4</td>
	<td  class="noborder">)</td>
</tr>
<tr><td  class="noborder"></td>
	<td  class="noborder">+0</td>
	<td  class="noborder">p 3</td>
	<td  class="noborder">)</td>
</tr>
<tr><td  class="noborder"></td>
	<td  class="noborder">+0</td>
	<td  class="noborder">p 2</td>
	<td  class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;codewords</td>
</tr>
<tr><td  class="noborder"></td>
	<td  class="noborder">p 1</td>
	<td  class="noborder">p 1</td>
	<td  class="noborder">)</td>
</tr>
<tr>
	<td  class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&pound;P</td>
	<td  class="noborder">&pound;CAT</td>
	<td  class="noborder">&pound;FRE</td>
</tr>
<tr>
	<td  class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;+O</td>
	<td  class="noborder">+O</td>
	<td  class="noborder">&pound;D</td>
	</tr>
<br>
<tr>
	<td  class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;wd 3</td>
	<td  class="noborder">wd 3</td>
	<td  class="noborder">wd 3</td>
</tr>
	<td  class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;wd 4</td>
	<td  class="noborder">wd 4</td>
	<td  class="noborder">wd 4</td>
	<td  class="noborder"></td>
</tr>
</table>

<p class="indent">
It can be seen that although P occupies a single 4 word
entry CAT requires two and FRED requires three entries of
4 words each.
</p>

<p><a href="Description Pages/page2.jpg">[PAGE iii]</a></p>

<p class="indent">
Parameters, if present, are described by codewords pl,
p2 etc. where p1 describes the first parameter, p2 the second
etc. Up to 4 parameters can be accommodated in a block of
four words. Codewords are as follows:-
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder"><u>Parameter type</u></td>
		<td class="noborder"><u>Codeword</u></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;real</td>
		<td class="noborder">&amp;106100</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;If called by value</td>
	</td>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;integer</td>
		<td class="noborder">&amp;106500</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;add the constant</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;boolean</td>
		<td class="noborder">&amp;105100</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;&amp;2000000</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;real array</td>
		<td class="noborder">&amp;046100</td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;integer array</td>
		<td class="noborder">&amp;046500</td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;boolean array</td>
		<td class="noborder">&amp;045100</td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;real procedure</td>
		<td class="noborder">&amp;116120</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;Procedures without</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;integer procedure</td>
		<td class="noborder">&amp;116520</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;parameters. For</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;boolean procedure</td>
		<td class="noborder">&amp;115120</td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;procedures with para-
		</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">)&nbsp;&nbsp;&nbsp;&nbsp;meters see below*
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;procedure</td>
		<td class="noborder">&amp;100120</td>
		<td class="noborder">)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;switch</td>
		<td class="noborder">&amp;040200</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;label</td>
		<td class="noborder">&amp;100200</td>
		<td class="noborder"> If called by value see above</td>
	</td>
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;string</td>
		<td class="noborder">&amp;000040</td>
		<td class="noborder"></td>
	</tr>
</table>

<p class="indent">
	The block of 4 words holding the name and its details has
	the first six characters of the name stored left justified and
	space filled in words 1 and 2.
</p>

<p class="indent">
	The third word wd 3 contains in its function part a l
	or a 2. If it contains a 1 then the procedure must be on
	the library tape and the address part of wd 3 must point to
	the name e.g.
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	&nbsp;1 ;-2
	<br>
</p>

<p>
	One can arrange a shared group of names, see for example SIN,
	COS and ARCTAN sharing the name QATRIG. If this is done then
	the shared name must <u>not start a block of four parameter entries</u>.
	If it does then the "reset names" part of initialisation will
	treat the block as a name and reset the used bit to zero,
	spuriously.
</p>

<p class="indent">
	If wd 3 contains a 2 in its function part then the 13 bit
	address part is treated as follows:-
</p>

<p class="indent">
	The five most significant digits form the function part
	of a pord and the eight least significant digits form the
	address part with zeros between the functions and address parts.
</p>

<center>
<img src="images/translator_fig1.jpg" alt="DIAGRAM"
		style="width:438;height:111 class=center">
</center>
<p>
	The function part is usually /15 or 15 for a PRIM or INOUT
	operation. If an INOUT operation is involved and the procedure
	name is discovered to be inside a <u>print</u> or <u>read</u> list, eleven
	is added to the address part. In theory one could generate
	any pord one likes. If a PRIM operation is involved and the
	procedure is a type procedure the PRIM UP which is normally
	produced is suppressed as is required by the interpreter.

</p>

<p><a href="Description Pages/page3.jpg">[PAGE iv]</a>

</p>

<p class="indent">
	The final word, wd 4, is constructed as follows:-
</p>

<table class="noborder">
<tr>
	<td class="noborder">real procedure &nbsp;&nbsp;&nbsp;)</td>
	<td class="noborder">&amp;116120</td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder">integer procedure ) without parameters</td>
	<td class="noborder">&amp;116520</td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder">boolean procedure )</td>
	<td class="noborder">&amp;115120</td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder">procedure
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</td>
	<td class="noborder">&amp;100120</td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder"></td>
	<td class="noborder"></td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder">real procedure &nbsp;&nbsp;&nbsp;)</td>
	<td class="noborder">&amp;036100</td>
	<td class="noborder"></td>
</tr>
<tr>
	<td class="noborder">integer procedure ) with parameters</td>
	<td class="noborder">&amp;036500</td>
	<td class="noborder">) plus the</td>
</tr>
<tr>
	<td class="noborder">boolean procedure )</td>
	<td class="noborder">&amp035100</td>
	<td class="noborder">) number of</td>
</tr>
<tr>
	<td class="noborder">procedure
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</td>
	<td class="noborder">&amp;020100</td>
	<td class="noborder">) parameters</td>
</tr>
</table>

<p class="indent">
	&nbsp;&nbsp;E.g. a real procedure with ten parameters would be &036112
</p>

<p class="indent">
	* The codeword for a real procedure with parameters is
	&amp;036100; note that the number of parameters is left blank in
	the codeword.
</p>

<p class="ul"">3.&nbsp;&nbsp;Assembly of the namelist</p>

<p class="indent">
Use SIR at 512 to assemble the namelist. Then dump
this by using the non-standard T22/23 to be found on the "USEFUL
TAPES" tape and an appropriate data tape.
</p>

<p class="ul">Adding namelist to translator</p>

<p class="indent">
After input of the relocatable translator tape clear out
the loader by using "CLEAR FROM 7168" on the "USEFUL TAPES" tape.
Then dump the store from 88-7999 inclusive using the non-standard
T22/23.
</p>

<p>
D. Hunter
</p>

<p><a href="Description Pages/page4.jpg">[PAGE -1-]</a></p>

<p class=ul>CONTENTS</p>
<ol>
	<li><a href="#INTRODUCTION">INTRODUCTION</a></li>
	<br>
	<li><a href="#LIMITATIONS">LIMITATIONS IMPOSED ON IFIP SUBSET ALGOL</a></li>
	<br>
	<li><a href="#DATASTORE">DATA STORE</a></li>
	<br>
	<li><a href="#CHARCODE">THE CHARACTER SET</a></li>
	<br>
	<li><a href="#STRUCTURE">PROGRAM STRUCTURE</a></li>
	<br>
	<li><a href="#TYPES">TYPE HANDLING</a></li>
	<br>
	<li><a href="#NOTATION">NOTATION</a></li>
	<br>
	<li><a href="#REFERENCES">REFERENCE LISTS</a></li>
	<br>
	<li><a href="#LISTING">NOTES ON TRANSLATOR LISTING</a></li>
</ol>

<p class=ul>Routines</p>

<p class=margin1>
	    <a href="#CENTRAL">CENTRAL LOOP</a>
	<br><a href="#FAIL">FAIL</a>
	<br><a href="#TAKCHA">TAKCHA</a>
	<br><a href="#IDENT">IDENTIFIER</a>
	<br><a href="#EVALNA">EVALNA</a>
	<br><a href="#NUMBER">NUMBER</a>
	<br><a href="#BCR">BCR</a>
	<br><a href="#UNSTAK">UNSTAK</a>
	<br><a href="#EXP">EXP</a>
	<br><a href="#PRAMCH">PRAMCH</a>
	<br><a href="#SEARCH">SEARCH</a>
	<br><a href="#SECODL">SECODL</a>
	<br><a href="#TAKID">TAKE IDENTIFIER</a>
	<br><a href="#TAKE">TAKE</a>
	<br><a href="#TYPCHK">TYPCHK</a>
	<br><a href="#ACTOP">ACTOP</a>
	<br><a href="#ARRAYBD">ARRAY BD</a>
	<br><a href="#DEC">DEC</a>
	<br><a href="#DECL">DECL</a>
	<br><a href="#ENDSTA">ENDSTA</a>
	<br><a href="#FORCOM">FORCOM</a>
	<br><a href="#FCLAPS">COLLAPSE FORMAL PARAMETERS (FCLAPS)</a>
	<br><a href="#NCLAPS">COLLAPSE NAME LIST (NCLAPS)</a>
	<br><a href="#REAL_INTEGER_BOOL">real, integer, boolean</a>
	<br><a href="#BEGIN">begin</a>
	<br><a href="#DO">do</a>
	<br><a href="#ELSE">else</a>
	<br><a href="#END">end</a>
	<br><a href="#FOR">for</a>
	<br><a href="#GOTO">goto</a>
	<br><a href="#IF">if</a>
	<br><a href="#PROC">procedure</a>
	<br><a href="#STEP_UNTIL_WHILE">step, UNTIL, while</a>
</p>

<p>
<a href="Description Pages/page5.jpg">[PAGE -2-]</a>
</p>

<p><u>Routines</u> continued</p>

<p class="margin1">
	    <a href="#SWITCH">switch</a>
	<br><a href="#THEN">then</a>
	<br><a href="#BECOMS">:= (BECOMS)</a>
	<br><a href="#SEMICO">; (SEMICO)</a>
	<br><a href="#AOP">arithmetic operators</a>
	<br><a href="#RLT">Relational operators</a>
	<br><a href="#LOGOP">Logical operators</a>
	<br><a href="#LSBRAK">[ (LSBRAK)</a>
	<br><a href="#RSBRAK">] (RSBRAK)</a>
	<br><a href="#COLON">: (COLON)</a>
	<br><a href="#COMMA">, (COMMA)</a>
	<br><a href="#LRBRAK">( (LRBRAK)</a>
	<br><a href="#RRBRAK">) (RRBRAK)</a>
	<br><a href="#QUOTE">{ string opening quote</a>
</p>

<p>
<a href="Description Pages/page6.jpg">[PAGE -3-]</a>
</p>

<p id=""INTRODUCTION" class="ul center">GENERAL STRATEGY OF THE TRANSLATOR</p>

<p id="INTRODUCTION">1.&nbsp;&nbsp;INTRODUCTION</p>

<p class="indent">
	The task of the Translator is to convert the ALGOL
	text into object program operations, which are assembled
	into object store by means of a loader/assembler, and
	obeyed interpretively at run time under the control of an
	Object Interpreter.
</p>

<p class="indent">
	Lack of space necessitates the translator for 903
	ALGOL to be one-pass, and object program operations are output
	as the source program is read in, Because insufficient store
	is available to hold the Translator, the translator Name List
	and subsidiary tables, and the object program, some such
	decision is imperative.
</p>

<p class="indent">
	The object program is essentially a form of "Reverse
	Polish" notation, and the Translator uses a stack to perform
	the necessary re-ordering of the ALGOL symbols, The Translator
	also uses a "Name List" which holds details of the
	declaration and use of the various identifiers, During
	translation a great many checks-are performed on the legality
	of the ALGOL text, but it cannot be claimed that these are
	exhaustive.
</p>

<p class="indent">
	The heart of the Translator is a routine called the
	"Basic Cycle Routine" (BCR) that extracts the next section
	of ALGOL text (a section being a string of characters ending
	with a delimiter such as "3" or begin ) ; control is then
	passed to a routine dealing with the delimiter concerned,
	and these routines may call further subroutines.
</p>

<p>
<a href="Description Pages/page7.jpg">[PAGE -4-]</a>
</p>

<p id="LIMITATIONS">2. &nbsp;&nbsp;LIMITATIONS IMPOSED ON IFIP subset ALGOL</p>

<p class="indent">
	IFIP subset ALGOL restricts "full" ALGOL in several
	important ways (one of these being the exclusion of
	recursion). 903 ALGOL has further restricted IFIP subset
	ALGOL, in particular in the following two areas:
<p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			2.1
		</td>
		<td class="noborder">
			All identifiers must be declared before they
			are allowed to appear in expressions or
			statenents. This simplifies a one-pass
			Translator's task considerably, as all
			relevant information about an identifier is
			in hand before it is actually used in
			processing.
			<p class=indent>
				This rule also applies to labels, which
				in 903 ALGOL must be declared in a switch
				list at the head of the block in which they
				occur. This does not disallow forward
				jumps; it merely allows the Translator to
				deduce to what level the jump is to be made.
			</p>

<pre class="margin4 courier">
<u>begin</u> <u>switch</u> S1 := FRED, JIM;
	<u>go to</u> JIM;
	FRED: ----
	<u>begin</u> <u>switch</u> S2:= JIM;
		----
		<u>go to</u> JIM;
	JIM: =---
		<u>go to</u> FRED;
	<u>end</u>;
	JIM: ---
<u>end</u>
</pre>
		<p>
			This means that there is no necessity to
			"chain" labels, with all its attendant
			complexities.
		</p>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			2.2
		</td>
		<td class="noborder">
			Expressions that should be of type Boolean may
			be of type arithmetic. Boolean expressions
			must reduce to the Boolean constants true and
			false, which in 903 ALGOL is considered
			equivalent to the values "&ne; zero" and "zero"
			respectively. Arithmetic expressions also
			reduce to these values at run time, and the
			Translator performs no check on this. As
			a result, the following constructs are permissible:

<pre class="margin4 courier">
<u>if</u> a+ b <u>then</u> ...
a := a > b
</pre>
			Note: Owing to the stack priorities involved,
			"a := a+a>b" is the equivalent of "a:= 2a>b"
			which will assign the value one or zero to
			"a" depending on-the truth or otherwise of the
			Boolean expression.
		</td>
	</tr>
</table>

<p>
<a href="Description Pages/page8.jpg">[PAGE -5-]</a>
</p>

<p id="DATASTORE">3.&nbsp;&nbsp;THE DATA STORE</p>

<p class="indent">
	The Translator requires the following storage areas:
<table class="noborder margin1t">
	<tr>
		<td class="noborder">(1)</td>
		<td class="noborder">Name list (<a href="#NAMELIST">NL</a>)</td>
	</tr>
	<tr class="noborder">
		<td class="noborder">(2)</td>
		<td class="noborder">
			Constants list, which includes label information
			from switch lists (<a href="#CODL">CODL</a>)
		</td>
	</tr>
	<tr>
		<td class="noborder">(3)</td>
		<td class="noborder">Stack</td>
	</tr>
	<tr>
		<td class="noborder">(4)</td>
		<td class="noborder">
			Buffer Area (<a href="#INBUF">INBUF</a>)
		</td>
	</tr>
	<tr>
		<td class="noborder">(5)</td>
		<td class="noborder">
			Work space area (<a href="#WORKSPACE">W</a>)
		</td>
	</tr>
</table>
<p id=NAMELIST class="margin1">3.1&nbsp;&nbsp;The Name List (NL)
<p class="margin2">
The name list contains the names and details of
all the identifiers with a current valid declaration. This list is
divided into blocks separated by block stoppers.
</p>

<p class="margin2 indent">
When a block closes, the Name list is then cleared back to its stopper.
</p>

<p class="margin2 indent">
A Name list entry is four words long and contains:
</p>

<p class="margin2">
<u>WORDS 1 and 2</u>
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			(i)&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			NAM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			First six characters not separators. Shorter names are stored left justified.
		</td>
	</tr>
</table>

<p class=margin2>
	<u>WORD 3 (from most significant)</u>
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			(ii)&nbsp;&nbsp;
			<br>&nbsp;
		</td>
		<td class="noborder">
			FML&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			Set if formal parameter (1 bit)
		</td>
	</tr>
		<td class="noborder">
			(iii)
			<br>&nbsp;
		</td>
		<td class="noborder">
			V
		</td>
		<td class="noborder">
			Set if call by value
			<br>
			Also set during procedure body to throw out recursive call (1 bit)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(iv)
			<br>&nbsp;
		</td>
		<td class="noborder">
			U
		</td>
		<td class="noborder">
			If identifier has been used (1 bit)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(v)
			<br>&nbsp;
		</td>
		<td class="noborder">
			Special
		</td>
		<td class="noborder">
			This procedure is interpreter not library (1 bit)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(vi)
			<br>&nbsp;
		</td>
		<td class="noborder">
			OWNCOD
		</td>
		<td class="noborder">
			Set if procedure is owncode (1 bit)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(vii)
			<br>&nbsp;
		</td>
		<td class="noborder">
			ADDRES
		</td>
		<td class="noborder">
			Address of identifier, or if formal parameter the parameter number (13 bits)
		</td>
	</tr>
</table>

<p class="margin2">
	<u>WORD 4</u> (from most significant).
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			(viii)
			<br>
			<br>&nbsp;
		</td>
		<td class="noborder">
			FD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			Set 1 on procedure assignment
			<br>
			Set 3 on leaving procedure body, and can fail trying to assign from outside
			(2 bits)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(ix)
			<br>&nbsp;
		</td>
		<td class="noborder">
			TYPE
		</td>
		<td class="noborder">
			Type of identifier (12 bits)
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(x)
			<br>&nbsp;
		</td>
		<td class="noborder">
			DIM
		</td>
		<td class="noborder">
			Dimensions of array or switch or number of parameters of a procedure (4 bits)
		</td>
	</tr>
</table>

<p class="margin2">
	A Block Stopper contains - 1 in word 1 and BN in Word 2.
</p>

<p>
<a href="Description Pages/page9.jpg">[PAGE -6-]</a>
</p>

<p id=CODL class="margin1">
	3.2&nbsp;&nbsp;Constants List (CODL)
</p>

<p class="margin2">
	This list holds the constants used in the source
	program; to prevent every constant taking up
	space each time it is used (as it would if the
	constants were inserted as they occurred into
	the object program) CODL is searched as each
	constant occurs to avoid duplication.
</p>

<p class="margin2 indent">
	The list also contains details of all switches
	and label declared during the source program.
	An example best illustrates its use;
</p>

<p class="margin2 indent">
	(assume in block 54)
</p>

<p class="margin2 indent">
	<u>Switch</u> S := LAB1, LAB2, LAB3;
</p>

<p class="margin2">
	sets up <a href="#NAMELIST">NL</a> and <a href="#CODL">CODL</a> as follows:-
</p>

<table class="noborder margin2t">
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;<u>Name List</u>
		</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder"><u>CODL</u></td>
	</tr>
	<tr>
		<td class="noborder">name</td>
		<td class="noborder">address</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">(in CODL)</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">S</td>
		<td class="noborder">1</td>
		<td class="noborder">+3 (count of labels)</td>
	</tr>
	<tr>
		<td class="noborder">LAB1</td>
		<td class="noborder">2</td>
		<td class="noborder">+0</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">54</td>
	</tr>
	<tr>
		<td class="noborder">LAB2</td>
		<td class="noborder">4</td>
		<td class="noborder">+0</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">54</td>
	</tr>
	<tr>
		<td class="noborder">LAB3</td>
		<td class="noborder">6</td>
		<td class="noborder">+0</td>
	</td>
	<tr>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder">54</td>
	</tr>
</table>

<p class="margin2 indent">
	When a label is met preceding a colon, it is
	looked up in <a href="#NL>NL</a>; from there the address in
	<a href="#CODL">CODL</a>
	is available, and the current program address
	is entered in <a href="#CODL">CODL</a> in place of the "+0", The
	block number must be in <a href="#CODL">CODL</a> to discover at run
	time how many entries should be unstacked on
	performing a jump to a label.
</p>

<p class="margin2 indent">
	These addresses have base address added at
	load time so are distinguishable to avoid their
	being used as constants at translate time.
</p>
	<table class="noborder margin2t">
		<tr>
			<th class="noborder"
				colspan=18 align=left>Name List Entry</th>
		<tr>
			<td class="center norightborder" colspan=6>N</td>
			<td class="center noleftborder norightborder"
			colspan=6>A</td>
			<td class="center noleftborder" colspan=6>M</td>
		</tr>
		<tr>
			<td class="center norightborder" colspan=6>E</td>
			<td class="center noleftborder norightborder"
			 	colspan=6>Space</td>
			<td class="center noleftborder" colspan=6>Space</td>
		</tr>
		<tr>
			<td class="centre">F<br>N<br>L</td>
			<td class="centre">V</td>
			<td class="centre">U</td>
			<td class="centre">s<br>p<br>e<br>c<br>i<br>a<br>l</td>
			<td class="centre">O<br>W<br>N<br>C<br>O<br>D</td>
			<td class="centre" colspan=13>
				<br><br><br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				ADDRES (13 bits)
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</td>
		</tr>
		<tr>
			<td class="centre" colspan=2>F D</td>
			<td class="centre" colspan=12>
				TYPE (12 bits)
			</td>
			<td class="centre" colspan=4>DIM (4 bits)</td>
		</tr>
		<tr>
			<td class="noborder"></td>
		</tr>
		<tr>
			<th class="noborder" colspan=18 align=left>PARAMETER ENTRY</th>
		</tr>
		<tr>
			<td class="centre">Z<br>E<br>R<br>O</td>
			<td class="centre">V</td>
			<td class="centre" colspan=12>
				<br><br>
				TYPE (12 bits)
			</td>
			<td class="centre" colspan=4>&nbsp;&nbsp;&nbsp;&nbsp;</td>
		</tr>
	</table>

<p>
	<a href="Description Pages/page10.jpg">[PAGE -7-]</a>
</p>

<p id=THESTACK class="margin1">
	3.2&nbsp;&nbsp;The Stack
</p>

<p class="margin2">
	The stack is used as a holding store to enable
	expressions to be converted into Reverse Polish,
	and also to deal with the nested statement structure.
	The next page shows a table of the stack - and
	compare - priorities used for delimiters. In
	general, operands are compiled, and operators are
	stacked. Unstacking is controlled by the stack
	priority, and loops UNTIL a stack priority is
	met that is less than that with which the unstacking procedure is called.
</p>

<table class="noborder margin2t">
	<tr>
		<th class="noborder" colspan=18 align=left>Stack Entry 1</th>
	</tr>
	<tr>
		<td class="centre" colspan=8>
			<br><br>CODE (8 bits)
		</td>
		<td class="centre">A<br>R<br>I<br>T<br>H</td>
		<td class="centre">E</td>
		<td class="centre">P<br>R<br>O<br>C</td>
		<td class="centre">T<br>Y<br>P<br>B<br>O<br>X</td>
		<td class="centre">G</td>
		<td class="centre">X<br>X</td>
		<td class="centre" colspan=4>
			<br><br>
			SPR (4 bits)
		</td>
	</tr>
	<tr>
		<td class="centre">M<br>R<br>E<br>A<br>D</td>
		<td class="centre">M<br>P<br>R<br>I<br>N<br>T</td>
		<td class="centre">L<br>O<br>G</td>
		<td class="centre">A<br>N</td>
		<td class="centre">R<br>E<br>L</td>
		<td class="centre" colspan=9>
			<br><br>
			BN (9 bits)
		</td>
		<td class="centre" colspan=4>
			<br><br>
			DIM (4 bits)
		</td>
	</tr>
	<tr>
		<td colspan=2>D<br>&nbsp;E<br>&nbsp;&nbsp;C<br>S<br>&nbsp;T<br>
		&nbsp;&nbsp;A</td>
		<td colspan=3></td>
		<td class="centre" colspan=13>
			<br><br>
			ADDRES (13 bits)
		</td>
	</tr>
	<tr>
		<td class="noborder" colspan=18 align=left>&nbsp</td>
	</tr>
	<tr>
		<th class="noborder" colspan=18 align=left>Stack Entry 2</th>
	</tr>
	<tr>
		<td colspan=8 class="centre">
			<br><br>
			CODE (8 bits)
		</td>
		<td class="centre">A<br>R<br>I<br>T<br>H</td>
		<td class="centre">E</td>
		<td class="centre">P<br>R<br>O<br>C</td>
		<td class="centre">T<br>Y<br>P<br>B<br>O<br>X</td>
		<td class="centre">G</td>
		<td class="centre">X<br>X</td>
		<td class="centre" colspan=4>
			<br><br>
			SPR (4 bits)
	</tr>
	<tr>
		<td class="centre">M<br>R<br>E<br>A<br>D</td>
		<td class="centre">M<br>P<br>R<br>I<br>N<br>T</td>
		<td class="centre">L<br>O<br>G</td>
		<td class="centre">A<br>N</td>
		<td class="centre">R<br>E<br>L</td>
		<td class="centre" colspan=9>
			<br><br>
			BN (9 bits)
		</td>
		<td class="centre" colspan=4>
			<br><br>
			DIM (4 bits)
		</td>
	</tr>
	<tr>
		<td class="centre" colspan=2>D<br>&nbsp;E<br>
		&nbsp;&nbsp;C<br>S<br>&nbsp;T<br>
		&nbsp;&nbsp;A</td>
		<td class="centre" colspan=12>
			<br><br>TYPE (12 bits)
		</td>
		<td colspan=4></td>
</table>

<p id=INBUF class="margin1">
	3.4&nbsp;&nbsp;Buffer Area
</p>

<p class=margin2>
	This area is 40 words long and stores source
	lines, the filling of this area is automatic.
	Once the Translator asks for a character either
	the next is supplied or it is found to be an nlcr
	and the buffer is refilled up to the next nlcr or
	a stopcode.
</p>

<p><a href="Description Pages/page11.jpg">[PAGE -8-]</a></p>

<p class="center "><u>TRANSLATOR STACK</u></p>
<table class="noborder">
	<tr>
		<th class="noborder">Stacked<br>Item</th>
		<th class="noborder">Stack<br>Priority</th>
		<th class="noborder">Compare<br>Priority</th>
		<th class="noborder">Remarks</th>
	</tr>
		<td class="noborder">[&nbsp;[<sub>A</sub></td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by ]</td>
	</tr>
	<tr>
		<td class="noborder">(</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by )</td>
	</tr>
	<tr>
		<td class="noborder">] ; end ,<br>)</td>
		<td class="noborder">void</td>
		<td class="noborder">1 <br>2</td>
		<td class="noborder">) not stacked; only used to
		<br>) unstack items</td>
	</tr>
	<tr>
		<td class="noborder">begin</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by <u>end</u></td>
	</tr>
	</tr>
	<tr>
		<td class="noborder">proc begin</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by ;</td>
	</tr>
	<tr>
		<td class="noborder">for</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by <u>do</u> or ,</td>
	</tr>
	<tr>
		<td class="noborder">simple</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by <u>step</u>
		<br><u>until</u> or <u>while</u></td>
	</tr>
	<tr>
		<td class="noborder">step, UNTIL, while</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by <u>do</u> or ,</td>
	</tr>
	<tr>
		<td class="noborder">MAMPS</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">replaced by [<sub>AD</sub></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">if</td>
		<td class="noborder">0</td>
		<td class="noborder">void</td>
		<td class="noborder">unstacked by <u>then</u></td>
	</tr>
	<tr>
		<td class="noborder">then E <br>else E</td>
		<td class="noborder">0 <br>2</td>
		<td class="noborder">2 <br>2</td>
		<td class="noborder">conditional expression</td>
	</tr>
	<tr>
		<td class="noborder">then S <br>else S</td>
		<td class="noborder">1 <br>1</td>
		<td class="noborder">2 <br> 2</td>
		<td class="noborder">conditional statement</td>
	</tr>
	<tr>
		<td class="noborder">GT, GTF <br>GTS, GTFS</td>
		<td class="noborder">2 <br>2</td>
		<td class="noborder">void <br>void</td>
		<td class="noborder"><u>go</u> <u>to</u> label&nbsp; )
			unstacked at<br><u>go</u> <u>to</u> switch )
			statement end</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">:=</td>
		<td class="noborder">2</td>
		<td class="noborder">12</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&equiv;</td>
		<td class="noborder">3</td>
		<td class="noborder">13</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&sup;</td>
		<td class="noborder">4</td>
		<td class="noborder">4</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&xvee;</td>
		<td class="noborder">5</td>
		<td class="noborder">5</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&xwedge;</td>
		<td class="noborder">6</td>
		<td class="noborder">6</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&not;</td>
		<td class="noborder">7</td>
		<td class="noborder">7</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&gt; &ge; = &le; &lt; &ne;</td>
		<td class="noborder">8</td>
		<td class="noborder">8</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">+ -</td>
		<td class="noborder">9</td>
		<td class="noborder">9</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&times; / NEG</td>
		<td class="noborder">10</td>
		<td class="noborder">10</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&uarr;</td>
		<td class="noborder">11</td>
		<td class="noborder">11</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">IND</td>
		<td class="noborder">12</td>
		<td class="noborder">12</td>
		<td class="noborder">array subscript</td>
	</tr>
</table>

<p><a href="Description Pages/page12.jpg">[PAGE -9-]</a></p>

<table id=WORKSPACE class="noborder margin1">
	<tr>
		<td class="noborder">
			3.5
		</td>
		<td class="noborder">
			The work space area is 15 words long. Although
			the coding in referring to the 5th word would
			address it as W+4, to avoid ambiguity it is
			referred as W4 and W+4 reserved for W plus the
			value 4.
		</td>
	</tr>
</table>

<p><a href="Description Pages/page13.jpg">[PAGE -10-]</a></p>

<p id=CHARCODE">
	4.&nbsp;&nbsp;THE CHARACTER SET
</p>

<p class="indent">
	There are 63 characters in the internal set. Their
	octal representation is shown below alongside the 503
	flexowriter symbol. The 4100 Westrex character is shown
	alongside in brackets when different.
</p>

<p class="red margin1">
	Note (i)&nbsp;&nbsp; (/) represents acute [single] quote on a 4100 Westrex
	teleprinter, and (\) is grave [single] quote.
</p>

<p class="red margin1">
	Note (ii)&nbsp; In other publications the 4100 Westrex teleprinter code is referred to
	as "903 Telecode".
</p>

<p class="red margin1">
	Note (iii) n the later "900 Telecode"", (/) becomes ' and (\) becomes @, &half;
	becomes &pound;, <sub>10</sub> becomes &amp;, &pound; becomes \, &uarr; becomes ^
	and &larr; becomes _.
</p>

<p class="red margin1">
	Note (iv) f interpreted as modern ASCII, (/) and (\) become ' and @ respectively, &half;
	becomes #, <sub>10</sub> becomes &amp;, &pound; becomes \, &uarr; becomes ^
	and &larr; becomes _.
<p>

<img src="images/translator_fig5.jpg" alt="DIAGRAM" style="height:195;width:597">

<p class="indent">
	e.g. The double character 1 overprinted by 2 in the
	503 code corresponds to &frac12; in the 4100 code and is represented
	internally as 3.
</p>

<p class="indent">
	Note nlcr is represented in the westrex code by carriage
	return, line feed and run out. This is handled on input
	to make line feed the operative symbol.
</p>

<p class="indent">
	Stop code is treated in most respects as an nlcr. Lt
	is recognised in <a href="#GETCHA">GETCHA</a> (<a href="#FILBUF">FILBUF</a>)
	and terminates the buffer filling. When the line has been processed the
	 increment line count is omitted and the program pauses.
</p>

<p class="indent">
	Becomes (:=) is left stored as two characters but the
	routine <a href="#GETCHA">GETCHA</a> has a look ahead facility to cope with this
	as it does with parameter comments in procedures.
</p>

<p class="indent">
	The colon equals sign must not contain a separator.
</p>

<p>
<a href="Description Pages/page14.jpg">[PAGE -11-]</a>
</p>

<p id=STRUCTURE>5.&nbsp;&nbsp;&nbsp;PROGRAM STRUCTURE
<p class="indent">
	A compound statement consists of a set of statements
	preceded by <u>begin</u> and followed by <u>end</u>. A block, however,
	has one or more declarations between <u>begin</u> and the set of
	statements which are again followed by the delimiter <u>end</u>.
	On meeting the first declaration after a <u>begin</u>, therefore,
	a block is implied.
</p>

<p class="indent">
	Whether or not an object block is set up depends
	entirely on the mode of storage used for the variables
	local to that block. The "wipe-off" mechanism at the end
	of an object block is best achieved by clearing back the
	stack pointer, without worrying whether to "block off" other
	areas of storage. There are two extremes to this problem:
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			i)
		</td>
		<td class="noborder">
			that all variables are kept on the stack,
			and hence there must be an object block
			generated for every source block; or
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			ii)
		</td>
		<td class="noborder">
			that there is so much room in store that
			all variables are given an absolute
			address in store and no object block need
			ever be generated. (Remember that we do
			not have to worry about recursion).
		</td>
	</tr>
</table>

<p class="indent">
	This translator steers a middle course; all scalars
	are given addresses in store, and arrays, formal parameters
	etc., are kept on the stack. As a result, an object block
	is only set up for the latter cases, This approach should
	be contrasted with Randell & Russell's method, which keeps
	all variables on the stack.
</p>

<p class="indent">
For object program operations see the pord manual.
</p>

<p>
	<a href="Description Pages/page15.jpg">[PAGE -12-]</a>
</p>

<p id=TYPES>
	6.&nbsp;&nbsp;&nbsp;TYPE HANDLING
</p>

<p class="ul margin1">
	6.1&nbsp;&nbsp;&nbsp;General
</p>

<p  class="indent margin1">
	The conversion of variables and expressions
	from <u>real</u> to <u>integer</u> or
	from <u>integer</u> to <u>real</u> is
	handled by the translator. Basically, the rules
	for determining the type of an expression are as
	follows: -
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			(i)
		</td>
		<td class="noborder">
			The type of an arithmetic operation is
			<u>integer</u> if both of the operands are of
			type <u>integer</u>, otherwise <u>real</u>.
			<br><br>
			* e.g. (a + b)x D
			<p class="margin3">
				a+b gives type <u>integer</u>; since
				D is <u>real</u>, (a + b) is converted to
				<u>real</u> before the multiplication is
				performed.
			<p>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(ii)
		</td>
		<td class="noborder">
			In an assignment statement, the expression
			on the right-hand side is converted to
			the type of left part list.
			<br><br>
			r := i := q + T
			<p class="margin3">
				q + T gives type real since T is
				<u>real</u>, and is converted to <u>integer</u>
				for the assignment to i. r being
				<u>integer</u> required that i, and any
				more elements of a multiple assignment should be of the same type.
			</p>

			<p>
				There are three conversion operations in the object code:-
			</p>

			<p class="margin2">
				(i) &nbsp;&nbsp;R to I &nbsp;&nbsp;convert 2nd operand to <u>integer</u>
			</p>

			<p class="margin2">
				(ii) &nbsp;I to R1  &nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
				&nbsp;operand to <u>real</u>
			</p>

			<p class="margin2">
				(iii) I to R2 &nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;lst
				operand to <u>real</u>
			</p>

			<p class="margin2">
				e.g. a := b + (D - e)
			</p>

			<p>
				The object code in reverse polish is:-
			</p>

			<p class="margin2">
				a
				<br>
				b
				<br>
				D
				<br>
				e
				<br>
				I to R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convert e
				to <u>real</u>
				<br>
				- R
				<br>
				L to R2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convert b to
				<u>real</u>
				<br>
				+ R
				<br>
				R to I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;convert
				b + (D-e)
				<br>
				:=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				to 	<u>integer</u>
			</p>

			<p>
				The translation of conditional expressions
				when type conversion is involved, is
				illustrated in the following example:-
			</p>
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page16.jpg">[PAGE -13-]</a>
</p>

<p class="margin4">
	A := b + (<u>if</u> p &lt; q <u>then</u> d <u>else</u> I);
	<br><br>
	a - z denote a variable of type <u>integer</u>
	<br>
	A - Z&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;
	&nbsp;"&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;<u>real</u>
</p>

<p>
	<a href="Description Pages/page17.jpg">[PAGE -14-]</a>
</p>

<p class="margin2 indent">
	Since the <u>else</u> part produces a <u>real</u> result,
	the <u>then</u> part must also produce a <u>real</u> result.
	The object code in reverse polish is:-
</p>

<img src="images/translator_fig6.jpg" alt="DIAGRAM" class="margin1"">
</p>

<p class="margin2">
	* The conversion (I to RL) cannot be placed here
	since in a single scan the translator is unable to
	know that the else part will give a real result.
</p>

<p class="ul margin1">
6.2&nbsp;&nbsp;&nbsp;Rules for Type Determination
</p>
<p class="margin2">
	(i)&nbsp;&nbsp; <u>Assignment</u> Right hand part converted to left-hand part.
</p>

<p class="margin4">
	a: = b+ D; (b + D) is converted to
	<u>integer</u>.
</p>

<p class="margin2">
	(ii)&nbsp; <u>Arithmetic or relational operation</u> If either operand is
	<u>real</u>,
</p>

<p class="margin4">
	a :=  (b + D) * e; b and e are converted to <u>real</u>.
</p>

<p class="margin4">
	a := <u>if</u> B &lt;d <u>then</u> p + q <u>else</u> y - R;
</p>

<p class="margin2">
	d is converted to <u>real</u> since B is <u>real</u> (p + q) and
	y are converted to <u>real</u> since R is <u>real</u>.
</p>

<p class="margin2">
	(iii) <u>Subscript expression</u> The subscript expression must give result
	<u>integer</u>.
</p>

<p class="margin4">
	a := A [b+ D] ; b is converted to <u>real</u> since D is<u>real</u>.
	(b + D) is converted to <u>integer</u> since it is a subscript.
</p>

<p class="margin2">
	(iv)&nbsp; <u>For Statements</u> The list elements must be converted to the same
	type as the controlled variable.
</p>

<p>
	<a href="Description Pages/page18.jpg">[PAGE -15-]</a>
</p>

<p class="margin4">
	<u>for</u> V := a,b <u>step</u> d <u>until</u> e, f <u>while</u> p &lt; q
	<u>do</u> . . . .
</p>

<p class="margin2">
	a,b,d,e and f are converted to <u>real</u> since V is <u>real</u>.
</p>
<p class="margin2">
	(v)&nbsp;&nbsp;&nbsp; <u>Actual Parameters</u> In a procedure call, the actual parameters must
	be converted to the type (<u>real</u> or <u>integer</u>) of the corresponding
	formal parameters.
</p>

<p>
	<a href="Description Pages/page19.jpg">[PAGE -16-]</a>
</p>

<p class="margin4">
	<u>procedure</u> P (a,B); <u>value</u> a,B;
	<u>integer</u> a; <u>real</u> B;
	<br><br>
	P (A,b); A is converted to <u>integer</u> and b to <u>real</u> to match the
	types of the formal parameters a and B.
</p>

<p class="margin2">
	(vi)&nbsp;&nbsp; <u>Division</u> Except when specifically required through use of a
	special Algol word <u>div</u>, the result of a division is <u>real</u>
	irrespective of the types of the operands, though there are 2 division
	operations in the object code. This is best illustrated in the following
	table:-
</p>

<table class="noborder margin3t">
	<tr>
		<th class="noborder">
			ALGOL <br>expression
		</th>
		<th class="noborder">
			Conversion
		</th>
		<th class="noborder">
			Object code <br>operation
		</th>
		<th class="noborder">
			<br>
			Result
		</th>
	</tr>
	<tr>
		<td class="nobottomborder">&nbsp;</td>
		<td class="nobottomborder"></td>
		<td class="nobottomborder"></td>
		<td class="nobottomborder"></td>
	</tr>
	<tr>
		<td class="notopborder nobottomborder">
			a/b
		</td>
		<td class="nobottomborder notopborder center">
			-
		</td>
		<td class="notopborder nobottomborder">
			/ integer
		</td>
		<td class="notopborder nobottomborder">
			real
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			A/B
		</td>
		<td class="nobottomborder notopborder">
			-
		</td>
		<td class="notopborder nobottomborder">
			/ real
		</td>
		<td class="notopborder nobottomborder">
			real
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			a/B
		</td>
		<td class="notopborder nobottomborder">
			I to R2
		</td>
		<td class="notopborder nobottomborder">
			/ real
		</td>
		<td class="notopborder nobottomborder">
			real
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			A/b
		</td>
		<td class="notopborder nobottomborder">
			I to R1
		</td>
		<td class="notopborder nobottomborder">
			/ real
		</td>
		<td class="notopborder nobottomborder">
			real
		</td>
	</tr>
	<tr>
		<td class="notopborder">
			a <u>div</u> b
		</td>
		<td class="notopborder">
			(fail if <br>either real)
		</td>
		<td class="notopborder">
			div
		</td>
		<td class="notopborder">
			integer
		</td>
	</tr>
</table>

<p class="margin2">
	(vii)&nbsp; <u>Exponentiation</u> This is similar to division, but there are third
	and fourth object codes for exponentiation.
</p>

<p class="margin3">
	(A) <u>Integer</u> exponentiation giving result <u>integer</u>.
	This operation may only occur when the mantissa is <u>integer</u> and the
	exponent is a positive <u>integer</u> constant.
</p>

<p class="margin3">
	(B) A special primitive for R &uarr; i stops the expression being failed
	out when the integer is negative.
</p>

<p class="margin2">
	The operations are illustrated below:-
</p>

<table class="noborder margin3t">
	<tr>
		<th class="noborder">
			ALGOL <br>expression
		</th>
		<th class="noborder">
			Conversion
		</th>
		<th class="noborder">
			Object code
			<br>
			operation
		</th>
		<th class="noborder">
			<br>
			Result
		</th>
	</tr>
	<tr>
		<td class="nobottomborder">
			a &uarr; b
		</td>
		<td class="center nobottomborder">
			-
		</td>
		<td class="nobottomborder">
			&uarr; integer (1)
		</td>
		<td class="nobottomborder">
			real
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			A &uarr; B
		</td>
		<td class="center nobottomborder notopborder">
			-
		</td>
		<td class="nobottomborder notopborder">
			&uarr; real (2)
		</td>
		<td class="nobottomborder notopborder">
			real
		</td>
	</tr>
	<tr class="noborder"">
		<td class="nobottomborder notopborder">
			A &uarr; b
		</td>
		<td class="nobottomborder notopborder">
			I to R2
		</td>
		<td class="nobottomborder notopborder">
			&uarr; real (2)
		</td>
		<td class="nobottomborder notopborder">
			real
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			a &uarr; integer constant
		</td>
		<td class="center notopborder nobottomborder">
			-
		</td>
		<td class="nobottomborder notopborder">
			&uarr; integer (3)
		</td>
		<td class="nobottomborder notopborder">
			integer
		</td>
	</tr>
	<tr>
		<td class="notopborder">
			A &uarr; b
		</td>
		<td class="center notopborder">
			-
		</td>
		<td class="notopborder">
			&uarr; special (4)
		</td>
		<td class="notopborder">
			real
		</td>
	</tr>
</table>

<p class="ul margin2">
6.3&nbsp;&nbsp;&nbsp;Type determination in the Translator
</p>

<p class="margin2 indent">
	A global variable <a href="#TYPBOX">TYPBOX</a> contains the current type
	(<u>real</u> or
	<u>integer</u>) of an ALGOL arithmetic expression. This is set by every
	 arithmetic
	identifier or constant when compiling the object code for the operand (in
	<a href="#TAKE">TAKE</a>) and is 	stacked with the binary operator which
	 follows.
	When the expression is unstacked this type is unstacked into LOKTYP, TYPBOX
	 is set
	to the resulting type of the expression and any conversions necessary are
	compiled.
</p>

<p>
	<a href="Description Pages/page20.jpg">[PAGE -17-]</a>
</p>

<p class="ul margin3">
	Example
</p>

<p class="margin4">
A := d + E * f;
</p>

<table class="noborder margin3">
	<tr>
		<th class="noborder">
			Translator
			<br>
			stack
		</th>
		<th  class="noborder">
			TYPBOX
		</th>
		<th class="noborder">
			Object
			<br>
			code
		</th>
		<th  class="noborder">
		</th>
		<th class="noborder">
		</th>
	</tr>
	<tr>
		<td>
			:= (R)
		</td>
		<td>
			real
		</td>
		<td>
			A
		</td>
		<td>
			A
			<br>
			:=&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td>
		</td>
	</tr>
	<tr>
		<td>
			+(i)
		</td>
		<td>
			integer
		</td>
		<td>
			d
		</td>
		<td>
			d
			<br>
			+
		</td>
		<td>
		</td>
	</tr>
	<tr>
		<td>
			*(R)
		</td>
		<td>
			real
		</td>
		<td>
			E
		</td>
		<td>
			E
			<br>
			*
		</td>
		<td>
		</td>
	</tr>
	<tr>
		<td>
		</td>
		<td>
			integer
		</td>
		<td>
			f
		</td>
		<td>
			f
			<br>
			;
		</td>
		<td>
			unstacks the
			<br>
			statement
		</td>
	<tr>
		<td>
		</td>
		<td>
			real
		</td>
		<td>
			I to R1
			<br>
			*R
		</td>
		<td>
		</td>
		<td>
			convert f to real
		</td>
	</tr>
	<tr>
		<td>
		</td>
		<td>
			real
		</td>
		<td>
			I to R2
			<br>
			+R
		</td>
		<td>
		</td>
		<td>
			convert f to real
		</td>
	</tr>
	<tr>
		<td>
			<br><br>
		</td>
		<td>
			real
		</td>
		<td>
			:=
		</td>
		<td>
		</td>
		<td>
		</td>
	</tr>
</table>

<p class="margin2 indent">
	On unstacking the decision of whether to compile a conversion or not, is made by
	comparing <a href="#TYPBOX">TYPBOX</a> with the type stacked with the operator.
</p>

<p class="margin3 ul">
	TRANSLATOR Conversion Rules
</p>

<p class="margin3">
	(i)&nbsp;&nbsp; Each identifier or constant sets
	<a href="#TYPBOX">TYPBOX</a> to its type
	(<u>real</u> or <u>integer</u>) in <a href="#TAKE">TAKE</a>.
</p>

<p class="margin3">
	(ii)&nbsp; The type from <a href="#TYPBOX">TYPBOX</a> is stacked with + - * / , &lt;
	&lt;= = &gt; &gt;= &ne;, :=, [, <u>else</u>, for comma, for:=, step, UNTIL, while.
	With the exception of [, the type stacked is that of the preceding variable or
	expression. In the case of [ it is the type of the preceding array identifier.
	Boolean is stacked as integer.
</p>

<p class="margin3">
	(iii)&nbsp; In the subroutine <a href="#UNSTAK">UNSTAK</a>, the type stacked with
	the operator (e.g. + i) is compared with the current type in <a href="#TYPBOX">
	TYPBOX</a>. A conversion is compiled if necessary and the relevant operator
	compiled (e.g. + R). The current expression type is then placed in
	<a href="#TYPBOX">TYPBOX</a>.
</p>

<p class="margin3">
	(iv)&nbsp;&nbsp; <u>Conditional Expressions</u> The type of the <u>then</u>
	 part is stacked
	with <u>else</u>. On unstacking the <u>else</u> part, the type stacked with
	<u>else</u> is compared with the type of the <u>else</u> part (in
	<a href="#TYPBOX">TYPBOX</a>) and a conversion compiled where n necessary.
</p>

<p>
	<a href="Description Pages/page21.jpg">[PAGE -18-]</a>
</p>

<p class="margin3">
	(v)&nbsp;&nbsp;&nbsp; The operators &uarr; and /  always leave
	<a href="#TYPBOX">TYPBOX</a> set
	to <u>real</u> on unstacking except for <u>div</u> and I &uarr; I as
	noted in 	6.2(vi) and (ii).
</p>

<p class="margin3">
	(vi)&nbsp;&nbsp; The assignment operator := requires a conversion to the
	type stacked
	with it.
</p>

<p class="margin3">
	(vii)&nbsp; <u>Array element</u> On unstacking a subscript expression
	 requires the
	type
	to be <u>integer</u> and a conversion is compiled if the expression is
	<u>real</u>. 	The type of the array, stacked with [, is then placed
	in <a href="#TYPBOX">TYPBOX</a>.
</p>

<p class="margin3">
	(viii) <u>Procedure call</u> If the call is to a type procedure (i.e. it
	yields a
	value) the type of the procedure is set in <a href="#TYPBOX">TYPBOX</a>
	 after
	compiling the call at ) or <a #TAKID">TAKID</a>.
</p>

<p class="margin3">
	(ix)&nbsp;&nbsp; The expression bracket '(', <u>if</u> and <u>then</u> do
	not require
	a type
	to be stacked with them nor do they change <a href="#TYPBOX">TYPBOX</a> on
	unstacking.
</p>

<p class="margin3">
	(x)&nbsp;&nbsp;&nbsp; <u>For statements</u> The type of the controlled
	variable is
	stacked with the
	start of each list element. On unstacking the list element expression, a
	conversion to the stacked type is compiled if necessary, and the type again
	stacked with the start of the next list element.
</p>

<p class="margin3">
	(xi)&nbsp;&nbsp; <u>Actual Parameters</u> These are dealt with in the
	subroutine
	<a href="#PRAMCH">PRAMCH</a> which determines whether to
	compile a conversion or not by
	comparing type of the actual parameter with the type of the formal parameter
	(this 	information is found in the <a #NAMELIST">Namelist</a>).
	<a href="#TYPBOX">TYPBOX</a>
	holds the actual parameter type, if this is an expression.
</p>

<p class="ul margin2">
COMPARISON between operator type and <a href="#TYPBOX">TYPBOX</a>
</p>
<table class="noborder margin0t">
	<tr>
		<th class="noborder">
			Operand 1
			<br><br>
		</th>
		<th class="noborder">
			Operand 2
		</th>
		<th class="noborder" colspan="2">
			Object code conversion
		</th>
	</tr>
		<th class="noborder">
			See note
		</th>
		<th class="noborder">
			See note
		</th>
		<th class="noborder">
			expression
		</th>
		<th class="noborder">
			else
		</th>
	</tr>
	<tr>
		<td class="nobottomborder">
			&nbsp;
		</td>
		<td class="nobottomborder">
			&nbsp;
		</td>
		<td class="nobottomborder">
			&nbsp;
		</td>
		<td class="nobottomborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			op I
		</td>
		<td class="nobottomborder notopborder">
			-
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			op R
		</td>
		<td class="nobottomborder notopborder">
			-
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			I to R1,
			<br>
			op R
		</td>
		<td class="nobottomborder notopborder">
			I to R1
		</td>
	</tr>
	<tr>
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			I to R2
			<br>
			op R
		</td>
		<td class="nobottomborder notopborder">
			UJ, I to
			<br>
			R1
		</td>
	</tr>
	<tr>
		<td class="notopborder">
			&nbsp;
			</td>
		<td class="notopborder">
		</td>
		<td class="notopborder">
		</td>
		<td class="notopborder">
		</td>
	</tr>
</table>

<br>
<br>

<table class="noborder margin0t">
	<tr>
		<th class="noborder">
			Operand 1
			<br><br>
		</th>
		<th class="noborder">
			Operand 2
		</th>
		<th class="noborder" colspan="2">
			Object code conversion
		</th>
	</tr>
		<th class="noborder">
			See note
		</th>
		<th class="noborder">
			See note
		</th>
		<th class="noborder">
			:=
		</th>
		<th class="noborder">
			/
		</th>
		<th class="noborder">
			[
		</th>
	</tr>
	<tr>
		<td class="nobottomborder">
			&nbsp;
		</td>
		<td class="nobottomborder">
		&nbsp;
	</td>
		<td class="nobottomborder">
		&nbsp;
	</td>
		<td class="nobottomborder">
		&nbsp;
	</td>
		<td class="nobottomborder">
		&nbsp;
	</td>
	</tr>
	<tr  class="noborder">
		<td class="nobottomborder notopborder">
		integer
	</td>
		<td class="nobottomborder notopborder">
		integer
	</td>
		<td class="nobottomborder notopborder">
		:=
	</td>
		<td class="nobottomborder notopborder">
		op I
	</td>
		<td class="nobottomborder notopborder">
		-
	</td>
	</tr>
	<tr  class="noborder">
		<td class="nobottomborder notopborder">
		real
	</td>
		<td class="nobottomborder notopborder">
		real
	</td>
		<td class="nobottomborder notopborder">
		o:=
	</td>
		<td class="nobottomborder notopborder">
		op R
	</td>
		<td class="nobottomborder notopborder">
		R to I
	</td>
	</tr>
	<tr  class="noborder">
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			I to R1,
			<br>
			:=
			<br>
			(special R I)
		</td>
		<td class="nobottomborder notopborder">
			I to R1
			<br>
			op R
		</td>
		<td class="nobottomborder notopborder">
			-
		</td>
	</tr>
	<tr  class="noborder">
		<td class="nobottomborder notopborder">
			integer
		</td>
		<td class="nobottomborder notopborder">
			real
		</td>
		<td class="nobottomborder notopborder">
			R to I,
			<br>
			:=
		</td>
		<td class="nobottomborder notopborder">
			I to R2
			<br>
			op R
		</td>
		<td class="nobottomborder notopborder">
			R to I
		</td>
	</tr>
	<tr  class="noborder">
		<td class=" notopborder">
			&nbsp;
		</td>
		<td class="notopborder">
		</td>
		<td class="notopborder">
		</td>
		<td class="notopborder">
		</td>
		<td class="notopborder">
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page22.jpg">[PAGE -19-]</a>
</p>

<p class="margin2">
	<u>Note</u> op R, op I denote an operator of type <u>real</u> or
	<u>integer</u>. Operand 1 is the variable or expression
	preceding the stacked operator, or the left part of
	assignment, or the <u>then</u> part and conditional expression,
	or the array identifier.
</p>

<p class="margin2">
	Operand 2 is the variable or expression following
	the stacked operand, or the RH side of an assignment,
	or the <u>else</u> part in a conditional expression or the
	array subscript.
</p>

<p>
	<a href="Description Pages/page23.jpg">[PAGE -20-]</a>
</p>

<p class="ul" id="NOTATION">
7.&nbsp;&nbsp;&nbsp;NOTATION
<p>

<p class="indent">
	The action of taking the item at the top of the
	stack and distributing the various constituent parts
	of the item into fixed locations is denoted by the
	procedure <a href="#RESTO">RESTO</a>. The parameters to this procedure
	correspond to some or all of the constituent parts
	of the item at the top of the stack. Those parts
	that are to be stored in fixed locations are indicated
	by a parameter, enclosed in square brackets, giving the
	name of the location. The final action of RESTO is
	to decrease <a href="#SP">SP</a> (the stack pointer) by one, and setting
	<a href="#TS">TS</a> to be the current top of stack.
</p>

<p class="indent">
	For example, if the item at the top of the stack
	is

<p class="margin2">
	<u>begin TR</u>, 53, 1026, O
</p>
<p class="margin1">
	then RESTO [.... BN , Q ]
</p>
<p class="margin1">
	deletes this item, having set BN to be
	53 and Q to be 1026.
</p>

<p class="indent">
	The procedure <a href="#PRESTO">PRESTO</a> is a variant of RESTO which
	does not decrease SP and TS then remains the same.
</p>

<p class="indent">
	The subroutine <a href="#STACK">STACK</a> has, as parameters given on
	separate lines and enclosed in square brackets, any
	items which are to be added to the stack. The stack
	priorities are indicated by the final underlined integer.
</p>

<p class="indent">
	For example,
</p>

<img class="margin2" src="images/translator_fig9.jpg" alt="DIAGRAM">

<p class="margin1">
	will stack the item "DECSTAT, NLP, BN, PP"
	and then the item "<u>proc</u> <u>begin</u> , <u>Q</u>".
</p>

<p class="indent">
	The subroutine <a href="#COMPIL">COMPIL</a> uses a similar notation to
	indicate any operations (and their parameters) to be
	added to the object program.
</p>

<p>
	<a href="Description Pages/page24.jpg">[PAGE -21-]</a>
</p>

<p class="indent">
	A subscripted item has the subscript value enclosed in square brackets.
	If an identifier is enclosed in round brackets this may be taken as 'contents of',
	e.g.,
</p>
<table class="noborder margin1t">
	<tr>
		<td class="noborder middle">
			(NLP) :=
		</td>
		<td class="noborder">
			-1
			<br>
			BN
		</td>
	</tr>
<table>

<p>
is putting a block stopper in the name list, -l is put
where the name list pointer points and the Block Number
goes in the next word, Replacing the Global Block Number;
<br>
	BN := (NLP+1) rather than BN := NLP[1].
</p>

<p class="indent">
	To make stacking easier, the Global variables take the values corresponding to the
	stacked position, E for
	example is stacked as the 9th significant bit of word one,
	and consequently the variable is carried about as O or
	+256 in the coding. The flowchart however refers to E
	as O or l. It is thought safer for other multistate
	variables to refer to their actual values (DECSTA := /0 0).
</p>

<p  id=GRPCODINF class="indent">
	Values of masks are not shown in the flowcharts:
	GRPCOD := masked TABLE [LASTCH+1] implies the mask
	is the 12 most significant bits, and in agreement with
	SIR conventions the bits mean:
</p>

<img src="images/translator_fig10.jpg" alt="DIAGRAM"
		class="margin0t">

<p class="indent">
	Also, similar to SIR, there exists a variable called
	<a href="#OPTION">OPTION</a> which varies the action of the translator.
</p>

<p>
	<a href="Description Pages/page25.jpg">[PAGE -22-]</a>
</p>

<p class="indent">
	The bits mean:
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder center">
			1
		</td>
		<td class="noborder">
			Halt on error
		</td>
	</tr>
	<tr>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			2
		</td>
		<td class="noborder">
			Warning mode
		</td>
	</tr>
	<tr>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder">
			4
		</td>
		<td class="noborder">
			Output check functions
		</td>
	</tr>
	<tr>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
		<td class="noborder" colspan=2>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder">
			8
		</td>
		<td class="noborder">
			Inhibit library scan
		</td>
	</tr>
</table>


<p>
	The method of testing is shown as e.g.:
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">
			OPTION
			<br>
			2 bit
		</td>
		<td class="noborder">
			in a decision box
		</td>
	</tr>
</table>

<p class="indent">
	Finally, in dealing with the flowcharts, certain
	abbreviations have been used, but it is hoped that in
	the main they are self evident, some examples are given
	below.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder center">
			nlcr
		</td>
		<td class="noborder">
			new line carriage return
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			inc
		</td>
		<td class="noborder">
			Increment (Var := Var + 1)
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			Acc
		</td>
		<td class="noborder">
			Accumulator
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			Aux
		</td>
		<td class="noborder">
			Auxiliary register
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			Str
		</td>
		<td class="noborder">
			String
		</td>
	</tr>
	<tr>
		<td class="noborder center">
			Real/int/Bool )
			<br>
			&nbsp;&nbsp;R / I / B&nbsp;&nbsp;&nbsp;)
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scalar&nbsp;&nbsp;&nbsp;)
		</td>
		<td class="noborder">
			<br>
			real, integer or boolean
		</td>
	</tr>
</table>

<p>
	Note The symbols &and; and &or; are also used in logical tests,
	e.g.
</p>

<p class="margin2">
	(E=0) &and; (M=1)
</p>

<p id=REFERENCES>
	8.&nbsp;&nbsp;&nbsp;<u>Reference Lists</u>
</p>

<p class="indent">
	It has been found convenient to have certain lists
	available for immediate reference, These are:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">
			(i)&nbsp;&nbsp;
			<br><br>
		</td>
		<td class="noborder">
			<a href="#TYPECODES">Types</a> (bit patterns corresponding to types of
			 variables);
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(ii)&nbsp;
			<br><br>
		</td>
		<td class="noborder">
			<a href="#DELIMITERS">Delimiter 8 bit values</a>
			(in practice stored at most significant end);
		</td>
	</tr>
	<tr class="noborder">
		<td class="noborder">
			(iii)
			<br><br>
		</td>
		<td class="noborder">
			Correspondence of routines to <a href="#ERRORS">error numbers</a>;
		</td>
	</tr>
	<tr border="noborder">
		<td class="noborder">
			(iv)&nbsp;
			<br><br>
		</td>
		<td class="noborder">
			Glossary of <a href="#GLOBALS">Global variables</a> used.
		</td>
	</tr>
</table>
</p>

<p>
	<a href="Description Pages/page26.jpg">[PAGE -23-]</a>
</p>

<p id="TYPECODES">
	(i)&nbsp;&nbsp;&nbsp;<u>Types</u>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder">a b c</td>
		<td class="noborder">A B C</td>
		<td class="noborder">D E F</td>
		<td class="noborder">G H J</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">real</td>
		<td class="noborder">106100</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">0 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">integer</td>
		<td class="noborder">106500</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">boolean</td>
		<td class="noborder">105100</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">0 1 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">real array</td>
		<td class="noborder">046100</td>
	</tr>
	<tr>
		<td class="noborder">0 1 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">0 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">integer array</td>
		<td class="noborder">046500</td>
	</tr>
	<tr>
		<td class="noborder">0 1 0</td>
		<td class="noborder">0 1 1</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">boolean array</td>
		<td class="noborder">045100</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">0 0 1</td>
		<td class="noborder">1 1 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">real procedure</td>
		<td class="noborder">036100</td>
	</tr>
	<tr>
		<td class="noborder">0 0 1</td>
		<td class="noborder">1 1 1</td>
		<td class="noborder">0 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">integer procedure</td>
		<td class="noborder">036500</td>
	</tr>
	<tr>
		<td class="noborder">0 0 1</td>
		<td class="noborder">1 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">boolean procedure</td>
		<td class="noborder">020100</td>
	</tr>
	<tr>
		<td class="noborder">0 0 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">procedure</td>
		<td class="noborder">020100</td>
	</tr>
	<tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 1 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 1</td>
		<td class="noborder">real procedure zero</td>
		<td class="noborder">116120</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 1 0</td>
		<td class="noborder">0 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">integer procedure zero</td>
		<td class="noborder">116520</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 1 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">1 0 1</td>
		<td class="noborder">boolean procedure zero</td>
		<td class="noborder">115120</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">1 0 0</td>
		<td class="noborder">procedure zero</td>
		<td class="noborder">100120</td>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">0 1 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">switch</td>
		<td class="noborder">040200</td>
	</tr>
	<tr>
		<td class="noborder">1 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 1</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">label</td>
		<td class="noborder">100200</td>
	</tr>
	<tr>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 0 0</td>
		<td class="noborder">0 1 0</td>
		<td class="noborder">string</td>
		<td class="noborder">000040</td>
	</tr>
</table>

<br>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">a</td>
		<td class="noborder">must not be followed by a bracket</td>
	</tr>
	<tr>
		<td class="noborder">b</td>
		<td class="noborder">must be followed by a [ bracket<>/td>
	</tr>
	<tr>
		<td class="noborder">c</td>
		<td class="noborder">must be followed by a ( bracket</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">A</td>
		<td class="noborder">type procedure</td>
	</tr>
	<tr>
		<td class="noborder">B</td>
		<td class="noborder">Algebraic (Arith &or; boolean)</td>
	</tr>
	<tr>
		<td class="noborder">C</td>
		<td class="noborder">Arithmetic</td>
	</tr>

	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">D</td>
		<td class="noborder">Boolean result</td>
	</tr>
	<tr>
		<td class="noborder">E</td>
		<td class="noborder">Integer result</td>
	</tr>
	<tr>
		<td class="noborder">F</td>
		<td class="noborder">Switch or label</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">G</td>
		<td class="noborder">Not a switch, label or string</td>
	</tr>
	<tr>
		<td class="noborder">H</td>
		<td class="noborder">String</td>
	</tr>
	<tr>
		<td class="noborder">J</td>
		<td class="noborder">Some procedure zero (paremeterless)</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page27.jpg">[PAGE -24-]</a>
</p>

<p id="DELIMITERS">
	(ii)&nbsp;&nbsp;&nbsp;<u>Delimiter 8 bit Codes (internal entities)</u>
</p>
<table class="noborder margin1t">
	<tr>
		<td class="noborder"><u>Octal</u></td>
		<td class="noborder"><u>Decimal</u></td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder center">0 - 63</td>
		<td class="noborder">As internal code for letters etc.</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">100</td>
		<td class="noborder center">64</td>
		<td class="noborder">Spare</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">65</td>
		<td class="noborder"><u>go</u> <u>to</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">66</td>
		<td class="noborder"><u>if</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">67</td>
		<td class="noborder"><u>for</u></td>
	</tr>
	<tr>
		<td class="noborder">104</td>
		<td class="noborder center">68</td>
		<td class="noborder"><u>end</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">69</td>
		<td class="noborder"><u>print</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">70</td>
		<td class="noborder"><u>read</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">71</td>
		<td class="noborder"><u>begin</u></td>
	</tr>
	<tr>
		<td class="noborder">110</td>
		<td class="noborder center">72</td>
		<td class="noborder"><u>code</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">73</td>
		<td class="noborder"><u>algol</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">74</td>
		<td class="noborder"><u>comment</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">75</td>
		<td class="noborder"><u>boolean</u></td>
	</tr>
	<tr>
		<td class="noborder">114</td>
		<td class="noborder center">76</td>
		<td class="noborder"><u>integer</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">77</td>
		<td class="noborder"><u>real</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">78</td>
		<td class="noborder"><u>array</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">79</td>
		<td class="noborder"><u>switch</u></td>
	</tr>
	<tr>
		<td class="noborder">120</td>
		<td class="noborder center">80</td>
		<td class="noborder"><u>procedure</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">81</td>
		<td class="noborder"><u>string</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">82</td>
		<td class="noborder"><u>label</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">83</td>
		<td class="noborder"><u>value</u></td>
	</tr>
	<tr>
		<td class="noborder">124</td>
		<td class="noborder center">84</td>
		<td class="noborder"><u>true</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">85</td>
		<td class="noborder"><u>false</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">86</td>
		<td class="noborder">&le;</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">87</td>
		<td class="noborder">&ge;</td>
	</tr>
	<tr>
		<td class="noborder">130</td>
		<td class="noborder center">88</td>
		<td class="noborder">&ne;</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">89</td>
		<td class="noborder">&equiv;</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">90</td>
		<td class="noborder"><u>implies</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">91</td>
		<td class="noborder"><u>or</u></td>
	</tr>
	<tr>
		<td class="noborder">134</td>
		<td class="noborder center">92</td>
		<td class="noborder"><u>and</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">93</td>
		<td class="noborder"><u>not</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">94</td>
		<td class="noborder"><u>then</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">95</td>
		<td class="noborder"><u>else</u></td>
	</tr>
	<tr>
		<td class="noborder">140</td>
		<td class="noborder center">96</td>
		<td class="noborder"><u>do</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">97</td>
		<td class="noborder">:=</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">98</td>
		<td class="noborder"><u>step</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">99</td>
		<td class="noborder"><u>until</u></td>
	</tr>
	<tr>
		<td class="noborder">144</td>
		<td class="noborder center">100</td>
		<td class="noborder"><u>while</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">101</td>
		<td class="noborder"><u>div</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">102 - 127</td>
		<td class="noborder">spare</td>
	</tr>
	<tr>
		<td class="noborder">200</td>
		<td class="noborder center">128</td>
		<td class="noborder">spare</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">129</td>
		<td class="noborder">then E</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">130</td>
		<td class="noborder">then S</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">131</td>
		<td class="noborder">begin TR</td>
	</tr>
	<tr>
		<td class="noborder">204</td>
		<td class="noborder center">132</td>
		<td class="noborder">begin ALL</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">133</td>
		<td class="noborder">for begin</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">134</td>
		<td class="noborder">simple</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">135</td>
		<td class="noborder">else E</td>
	</tr>
	<tr>
		<td class="noborder">210</td>
		<td class="noborder center">136</td>
		<td class="noborder">else S</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">137</td>
		<td class="noborder">GTF</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">138</td>
		<td class="noborder">GT</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">139</td>
		<td class="noborder">[<sub>AD</sub></td>
	</tr>
	<tr>
		<td class="noborder">214</td>
		<td class="noborder center">140</td>
		<td class="noborder">IND</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">141</td>
		<td class="noborder"><u>proc</u> <u>begin</u></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">142</td>
		<td class="noborder">GTS</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">143</td>
		<td class="noborder">GTFS</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">144</td>
		<td class="noborder">STA</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">145</td>
		<td class="noborder">NEG</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder center">146</td>
		<td class="noborder">MAMPS</td>
	</tr>
<table>

<p>
	<a href="Description Pages/page28.jpg">[PAGE -25-]</a>
</p>

<p id="ERRORS">
	(iii)&nbsp;&nbsp;&nbsp;<u>Table of error numbers</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">1</td>
		<td class="noborder"><a href="#OUT">OUT (Read)</a></td>
	</tr>
	<tr>
		<td class="noborder right">2</td>
		<td class="noborder"><a href="#OUT">OUT (Print)</u></td>
	</tr>
	<tr>
		<td class="noborder right">3</td>
		<td class="noborder"><a href="#SETPRO">SETPRO</a></td>
	</tr>
	<tr>
		<td class="noborder right">4</td>
		<td class="noborder"><a href="#SWITCH">SWITCH</a></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">5</td>
		<td class="noborder">
			<a href="#PRAMCH">PRAMCH</a>
			<a href="#ACTOP">ACTOP</a>
			<a href="#RRBRAK">RRBRAK</a>
			<a href="#QUOTE">QUOTE</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right"></td>
		<td class="noborder"><a href="# " </a></td>
	</tr>
	<tr>
		<td class="noborder right">6</td>
		<td class="noborder">
			<a href="#ACTOP">ACTOP</a>
			<a href="#PROCED">PROCED</a></td>
	</tr>
	<tr>
		<td class="noborder right">7</td>
		<td class="noborder">
			<a href="#NUMBER">NUMBER</a>
			<a href="#BECOMS">BECOMS</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">8</td>
		<td class="noborder"><a href="#NUMBER">NUMBER</a></td>
	</tr>
	<tr>
		<td class="noborder right">9</td>
		<td class="noborder"><a href="#COLON">COLON</a></td>
	</tr>
	<tr>
		<td class="noborder right">10</td>
		<td class="noborder"><a href="#BCR">BCR</a></td>
	</tr>
	<tr>
		<td class="noborder right"&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">11</td>
		<td class="noborder"><a href="#BCR">BCR</a></td>
	</tr>
	<tr>
		<td class="noborder right">11</td>
		<td class="noborder"><a href="#BCR">BCR</a></td>
	</tr>
	<tr>
		<td class="noborder right">12</td>
		<td class="noborder"><a href="#BCR">BCR</a></td>
	</tr>
	<tr>
		<td class="noborder right">13</td>
		<td class="noborder"><a href="#BCR">BCR</a></td>
	</tr>
	<tr>
		<td class="noborder right">14</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">15</td>
		<td class="noborder"><a href="#EVALNA">EVALNA</a></td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">16</td>
		<td class="noborder"><a href="#FCLAPS">FCLAPS</a></td>
	</tr>
	<tr>
		<td class="noborder right">17</td>
		<td class="noborder">
			<a href="#SEARCH">SEARCH</a>
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">18</td>
		<td class="noborder"><a href="#SEARCH">SEARCH</a></td>
	</tr>
	<tr>
		<td class="noborder right">19</td>
		<td class="noborder"><a href="#OUT">OUT</a></td>
	</tr>
	<tr>
		<td class="noborder right">20</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">21</td>
		<td class="noborder">
			<a href="#FOR">FOR</a>
			<a href="#STEP_UNTIL_WHILE">STEP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">22</td>
		<td class="noborder"><a href="#TAKID">TAKID</a></td>
	</tr>
	<tr>
		<td class="noborder right">23</td>
		<td class="noborder"><a href="#RSBRAK">RSBRAK</a></td>
	</tr>
	<tr>
		<td class="noborder right">24</td>
		<td class="noborder"><a href="#LSBRAK">LSBRAK</a></td>
	</tr>
	<tr>
		<td class="noborder right">25</td>
		<td class="noborder"><a href="#LRBRAK">LRBRAK</a></td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">26</td>
		<td class="noborder"><a href="#SWITCH">SWITCH</a></td>
	</tr>
	<tr>
		<td class="noborder right">27</td>
		<td class="noborder"><a href="#DECL">DECL</a></td>
	</tr>
	<tr>
		<td class="noborder right">28</td>
		<td class="noborder"><a href="#BECOMS">BECOMS</a></td>
	</tr>
	<tr>
		<td class="noborder right">29</td>
		<td class="noborder"><a href="#COLON">COLON</a></td>
	</tr>
	<tr>
		<td class="noborder right">30</td>
		<td class="noborder">
			<a href="#TAKE">TAKE</a>
			<a href="#AOP">AOP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">31</td>
		<td class="noborder">
			<a href="#TAKE">TAKE</a>
			<a href="#TAKID">TAKID</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">32</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">33</td>
		<td class="noborder">
			<a href="#LSBRAK">LSBRAK</a>
			<a href="#BCR">BCR</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">34</td>
		<td class="noborder"><a href="#UNSTAK">UNSTAK</a></td>
	</tr>
	<tr>
		<td class="noborder right">35</td>
		<td class="noborder">
			<a href="#EXP">EXP</a>
			<a href="#COLON">COLON</a>
			<a href="#QUOTE"></a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">36</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">37</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">38</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">39</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">40</td>
		<td class="noborder"><a href="#ENDSTA">ENDSTA</a></td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">41</td>
		<td class="noborder">
			<a href="#TAKID">TAKID</a>
			<a href="#LRBRAK">LRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">42</td>
		<td class="noborder"><a href="#GOTO">GOTO</a></td>
	</tr>
	<tr>
		<td class="noborder right">43</td>
		<td class="noborder"><a href="#FORCOM">FORCOM</a></td>
	</tr>
	<tr>
		<td class="noborder right">44</td>
		<td class="noborder"><a href="#FOR">FOR</a></td>
	</tr>
	<tr>
		<td class="noborder right">45</td>
		<td class="noborder"><a href="#TAKE">TAKE</a></td>
	</tr>
</table>

<p>
	<a href="Description Pages/page29.jpg">[PAGE -26-]</a>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    &nbsp;&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">46</td>
		<td class="noborder"><a href="#TAKID">TAKID</a></td>
	</tr>
	<tr>
		<td class="noborder right">47</td>
		<td class="noborder"><a href="#REAL">REAL</a></td>
	</tr>
	<tr>
		<td class="noborder right">48</td>
		<td class="noborder">
			<a href="#SEARCH">SEARCH</a>
			<a href="#COLON">COLON</a>
		</td>
	</tr>
	<tr>
		<td class="noborder"></td><td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder right">49</td>
		<td class="noborder">
			<a href="#ACTOP">ACTOP</a>
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">50</td>
		<td class="noborder">
			<a href="#ARRBND">ARRBND</a>
			<a href="#TITLE">TITLE</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">51</td>
		<td class="noborder">
			<a href="#PRAMCH">PRAMCH</a>
			<a href="#RSBRAK">RSBRAK</a>
			<a href="#RRBRAK">RRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">52</td>
		<td class="noborder">
			<a href="#BECOMS">BECOMS</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">53</td>
		<td class="noborder">
			<a href="#SEMICO">SEMICO</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">54</td>
		<td class="noborder">
			<a href="#DEC">DEC</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">55</td>
		<td class="noborder">
			<a href="#EXP">EXP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">56</td>
		<td class="noborder">
			<a href="#TAKCHA">TAKCHA</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">57</td>
		<td class="noborder">
			<a href="#AOP">AOP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">58</td>
		<td class="noborder">
			<a href="#RLT">RLT</a>
			<a href="#LOGOP">LOGOP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">59</td>
		<td class="noborder">
			<a href="#LOGOP">LOGOP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">60</td>
		<td class="noborder">
			<a href="#BEGIN">BEGIN</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">61</td>
		<td class="noborder">
			<a href="#SEARCH">SEARCH</a>
			<a href="#LRBRAK">LRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">62</td>
		<td class="noborder">
			<a href="#LRBRAK">LRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">63</td>
		<td class="noborder">
			<a href="#DEC">DEC</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">64</td>
		<td class="noborder">
			<a href="#UNSTAK">UNSTAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">65</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">66</td>
		<td class="noborder">
			<a href="#ARRBND">ARRBND</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">67</td>
		<td class="noborder">
			<a href="#IF">IF</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">68</td>
		<td class="noborder">
			<a href="#IF">IF</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">69</td>
		<td class="noborder">
			<a href="#THEN">THEN</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">70</td>
		<td class="noborder">
			<a href="#ELSE">ELSE</a>
		</td>
	</tr>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">71</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder right">72</td>
		<td class="noborder">
			<a href="#ARRAY">ARRAY</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">73</td>
		<td class="noborder">
			<a href="#LSBRAK">LSBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">74</td>
		<td class="noborder">
			<a href="#RSBRAK">RSBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">75</td>
		<td class="noborder">
			<a href="#RSBRAK">RSBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">76</td>
		<td class="noborder">
			<a href="#REAL">REAL</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">77</td>
		<td class="noborder">
			<a href="#COMMA">COMMA</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">78</td>
		<td class="noborder">
			<a href="#STEP_UNTIL_WHILE">STEP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">79</td>
		<td class="noborder">
			<a href="#NCLAPS">NCLAPS</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">80</td>
		<td class="noborder">
			<a href="#STEP_UNTIL_WHILE">STEP</a>
		</td>
	</tr>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">81</td>
		<td class="noborder">
			<a href="#RRBRAK">RRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">82</td>
		<td class="noborder">
			<a href="#LRBRAK">LRBRAK</a>
			<a href="#RRBRAK">RRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">83</td>
		<td class="noborder">
			<a href="#STACK">STACK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">84</td>
		<td class="noborder">
			<a href="#RRBRAK">RRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">85</td>
		<td class="noborder">
			<a href="#CHECK">CHECK</a>
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">86</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">87</td>
		<td class="noborder">
			<a href="#SEARCH">SEARCH</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">88</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">89</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder right">90</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">91</td>
		<td class="noborder">
			<a href="#GETCHA">GETCHA</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">92</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page30.jpg">[PAGE -27-]</a>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    &nbsp;&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">93</td>
		<td class="noborder">
			<a href="#STATRM">STATRM</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">94</td>
		<td class="noborder">
			<a href="#PRAMCH">PRAMCH</a>
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">95</td>
		<td class="noborder">
			<a href="#RSBRAK">RSBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">96</td>
		<td class="noborder">
			<a href="#FORCOM">FORCOMM</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">97</td>
		<td class="noborder">
			<a href="#THEN">THEN</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">98</td>
		<td class="noborder">
			<a href="#GETCHA">GETCHA</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">99</td>
		<td class="noborder">
			<a href="#SEARCH">SEARCH</a>
			<a href="#FORCOM">FORCOM</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">100</td>
		<td class="noborder">
			<a href="#IF">IF</a>
		</td>
	</tr>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">101</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">102</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">103</td>
		<td class="noborder">
			<a href="#ARRBND">ARRBND</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">104</td>
		<td class="noborder">
			<a href="#UNSTAK">UNSTAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">105</td>
		<td class="noborder">
			<a href="#QUOTE">QUOTE</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">106</td>
		<td class="noborder">
			<a href="#COLON">COLON</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">107</td>
		<td class="noborder">
			<a href="#FOMPIL">FOMPIL</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">108</td>
		<td class="noborder">
			<a href="#PRAMCH">PRAMCH</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">109</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">110</td>
		<td class="noborder">
			<a href="#PROCED">PROCED</a>
		</td>
	</tr>
	</tr>
	<tr>
		<td class="noborder right">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder right">111</td>
		<td class="noborder">
			<a href="#RRBRAK">RRBRAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder right">112</td>
		<td class="noborder">
			<a href="#BECOMS">BECOMES</a>
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page31.jpg">[PAGE -28-]</a>
</p>

<p id="GLOBALS">
	(iii)&nbsp;&nbsp;&nbsp;<u>GLOBAL VARIABLES</u>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder left" style="width:10ch"><u>Variable</u></td>
		<td class="noborder center" style="width:36ch"><u>Use</u></td>
		<td class="noborder left" style="width:21ch"><u>Set in</u></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>

	<tr>
		<td class="noborder left" id=ADDI>
		ADDI</td>
		<td class="noborder left">
			local copy of ADDRES (I)<br>
			ADDI+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			DIM (I)<br>
			ADDI+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			FML (I)<br>
			ADDI+3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			Used (I)<br>
			ADDI+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			V&nbsp;&nbsp;&nbsp; (I)
		</td>
		<td class="noborder left">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
			<a href="#FOMCOM">FOMCOM</a> )<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )&nbsp;&nbsp;&nbsp;
			<a href="#ADJI">ADJI</a><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id="ADDRES">
			ADDRES
		</td>
		<td class="noborder left">
			Temporary storage for unstacked address
		</td>
		<td class="noborder left">
			<a href="#UNSTAK">UNSTAK</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=AR>
			AR
		</td>
		<td class="noborder left">
			Not now used
		</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=ARITH>
			ARITH
		</td>
		<td class="noborder left">
			Checks validity of use of rel., or log.
			operators (fail if ARITH = 1)
		</td>
		<td class="noborder left">
			SET to 1 in [, <a href="#STEP">STEP</a>
			<a href="#SWITCH">SWITCH</a>
			<br>
			Cleared in <a href="#ENDSTA">ENDSTA</a>
			Do ElseS if ) ]
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=ARRCOU>
			ARRCOU
		</td>
		<td class="noborder left">
			Array count on array declaration
		</td>
		<td class="noborder left">
			<a href="#ARRAY">ARRAY</a> ] <a href="#DECL">DECL</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=BN>
			BN<br><br><br>&nbsp;
		</td>
		<td class="noborder left">
			Current block Name<br>
			<br>
			BN+2 Last found block Name<br>
			BN+4 Highest block Name used
		</td>
		<td class="noborder left">
			<a href="#DO">DO</a> <a href="#FOR">FOR</a>
			<a href="#DECL">DECL</a> &nbsp;&nbsp; )
			<br>
			<a href="#PROCED">PROCED</a>
			<a href="#NCLAPS">NCLAPS</a>&nbsp; )<br>
			<a href="#UNSTAK">UNSTAK</a>
			<a href="#SEARCH">SEARCH</a>&nbsp; )
			<a href="#START">START</a><br>
			<a href="#DEC">DEC</a> <a href="#FOR">FOR</a>
			<a href="#PROCED">PROCED</a> )
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=BUFLAG>
			BUFLAG
		</td>
		<td class="noborder left">
			Marker to show when input buffer exhausted
		</td>
		<td class="noborder left">
			<a href="#START">START</a> <a href="#GETCHA">GETCHA</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=C>
			C
		</td>
		<td class="noborder left">
			Zero constant
		</td>
		<td class="noborder left">
			<a href="#START">START</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=CHKSUM>
			CHKSUM
		</td>
		<td class="noborder left">
			Binary sum of characters for checking binary output
		</td>
		<td class="noborder left">
			<a href="#PUNGRP">PUNGRP</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=CNL>
			CNL
		</td>
		<td class="noborder left">
			Marker set during Name list collapse
		</td>
		<td class="noborder left">
			<a href="#NCLAPS">NCLAPS</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=CODE">
			CODE<br>&nbsp;
		</td>
		<td class="noborder left">
			Used by <a href="#PUNGRP">PUNGRP</a> to inform loader of type of
			 output<br>
			&nbsp;
		</td>
		<td class="noborder left">
			<a href="#COMPIL">COMPIL</a> <a href="#FOMPIL">FOMPIL</a><br>
			<a href="#PUNGLB">PUNGLB</a>
		</td>
	</tr>
	<tr>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
		<td class="noborder left">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=CODLP>
			CODLP<br>CONS
		</td>
		<td class="noborder left" id="CONS">
			Relative pointer to next free in <a href="#CODL">CODL</a><br>
			0; real constant. 1; integer, 2: Boolean (true/false)
		</td>
		<td class="noborder left">
			<a href="#START">START</a> <a href="#SECODL">SECODL</a><br>
			<a href="#NUMBER">NUMBER</a> <a href="#BCR">BCR</a>
		</td>
	</tr>
</table>

<br clear=left>

<p>
	<a href="Description Pages/page32.jpg">[PAGE -29-]</a>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder left" style="width:10ch"><u>Variable</u></td>
		<td class="noborder center" style="width:36ch"><u>Use</u></td>
		<td class="noborder left" style="width:21ch"><u>Set in</u></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=CONSTA>CONSTA</td>
		<td class="noborder left">
			Current constant in ALGOL text
		</td>
		<td class="noborder left">
			<a href="#NUMBER">NUMBER</a> <a href="#BCR">BCR</a>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="DECSTA">DECSTA</td>
		<td class="noborder left">
			0 at <u>begin</u>, 1 during declarations<br>
			2 during statements<br>
			&nbsp;
		</td>
		<td class="noborder left">
		<a href="#DEC">DEC</a> <a href="#FOR">FOR</a>
		<a href="#PROCED">PROCED</a><br>
		<a href="#BEGIN">BEGIN</a> <a href="#GOTO">GOTO</a>
		<a href="#IF">IF</a><br>
		<a href="#BECOMS">BECOMS</a> <a href="#COLON">COLON</a> (
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=DECTYP>
		DECTYP<br>&nbsp;</td>
		<td class="noborder left">
			Type of current declaration<br>
			&nbsp;
		</td>
		<td class="noborder left">
		<a href="#ARRAY">ARRAY</a> <a href="#REAL">REAL</a>
		<a href="#PROCED">PROCED</a><br>
		<a href="#SWITCH">SWITCH</a> ]
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=DELIM>
		DELIM<br>&nbsp;</td>
		<td class="noborder left">
			Current delimiter<br>
			DELIM+1 contains the associated <a href="#GRPCOD">GRPCOD</a>
		</td>
		<td class="noborder left">
		<a href="#BCR">BCR</a> <a href="#QUOTE">QUOTE</a>
		<a href="#AOP">AOP</a><br>
		<a href="#BCR">BCR</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=DIM">
		DIM</td>
		<td class="noborder left">
			Temporary storage for unstacked dimensions
		</td>
		<td class="noborder left">
		<a href="#UNSTAK">UNSTAK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=E>
		E<br><br><br><br><br>
		&nbsp;</td>
		<td class="noborder left">
			Set 1 for statement, 0 for expressions<br><br><br><br><br>
		&nbsp;</td>
		</td>
		<td class="noborder left">
		Set to 1 at<br>
		<a href="#ENDSTA">ENDSTA</a> <a href="#ACTOP">ACTOP</a>
		<a href="#SETPRO">SETPRO</a>
		<br>
		<a href="#ELSE">ELSE</a> <a href="#DO">DO</a> ] (<br>
		Set to 0 at<br>
		<a href="#EXP">EXP</a> <a href="#PRINT">PRINT</a>
		<a href="#QUOTE">QUOTE</a><br>
		<a href="#IF">IF</a> <a href="#GOTO">GOTO</a> [
		<a href="#FOR">FOR</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=EXPRES>
		EXPRES<br>
		<td class="noborder left">
			Set for expression bracket in print list
		</td>
		<td class="noborder left">
		<a href="#SETPRO">SETPRO</a> (
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=EXPTYP>
		EXPTYP<br><br>&nbsp;
		<td class="noborder left">
			Records expected type(s)<br><br>
			&nbsp;
		</td>
		<td class="noborder left">
		Set to Switch/Label in
		<a href="#GOTO">GOTO</a>
		<br>
		Cleared at<br>
		<a href="#ENDSTA">ENDSTA</a> <a href="#ELSE">ELSE</a>
		<a href="#IF">IF</a><br>
		, ) [
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=F>
		F
		<td class="noborder left">
			For clause marker
		</td>
		<td class="noborder left">
		<a href="#DO">DO</a> <a href="#FOR">FOR</a>
		<a href="#GOTO">GOTO</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=FALCOU>
		FALCOU
		<td class="noborder left">
			Register to accumulate error number
		</td>
		<td class="noborder left">
		<a href="#FAIL>FAIL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=G>
		G
		<td class="noborder left">
			Marker for syntax checks (for clauses)
		</td>
		<td class="noborder left">
		<a href="#FOR">FOR</a> <a href="#STEP_UNTIL_WHILE">STEP</a>
		<a href="#STEP_UNTIL_WHILE">WHILE</a>
		<a href="#STEP_UNTIL_WHILE">UNTIL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="GRPCOD">
		GRPCOD<br>&nbsp;
		<td class="noborder left">
			Information code for current delimiter
			or character (<a href="#GRPCODINF">Sec. 7</a>)
		</td>
		<td class="noborder left">
		<a href="#TAKCHA">TAKCHA</a> <a href="#GETCHA">GETCHA</a> <br>
		&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=I>
		I
		<td class="noborder left">
			Contains last value of NLP
		</td>
		<td class="noborder left">
		<a href="#SEARCH">SEARCH</a> [
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LASTCH>
			LASTCH<br><br><br>
		<td class="noborder left">
			Last character read from buffer<br>
			LASTCH+1 Present character<br>
			LASTCH+2 Next character
		</td>
		<td class="noborder left">
			)<br>
			) <a href="#GETCHA">GETCHA</a> <br>
			) <a href="#EVALNA">EVALNA</a> <br>
		&nbsp;
	</tr>
</table>

<br clear=left>

<p>
	<a href="Description Pages/page33.jpg">[PAGE -30-]</a>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder left" style="width:10ch"><u>Variable</u></td>
		<td class="noborder center" style="width:36ch"><u>Use</u></td>
		<td class="noborder left" style="width:21ch"><u>Set in</u></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=LASTOP>
			LASTOP<br><br><br>
		<td class="noborder left">
			Last item compiled
		</td>
		<td class="noborder left">
		<a href="#COMPIL">COMPIL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LASTDL>
			LASTDL<br><br>
		<td class="noborder left">
			Last delimiter<br>
			LASTDL+1 <a href="#GRPCOD">GRPCOD</a> of LASTDL
		</td>
		<td class="noborder left">
			<a href="#BCR">BCR</a> <br><br>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LEVEL>
			LEVEL
		<td class="noborder left">
			Not now used
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LHTYP>
			LHTYP
		<td class="noborder left">
			Left hand type of an assignment
		<td class="noborder left">
			<a href="#BECOMS">BECOMS</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LINE>
			LINE
		<td class="noborder left">
			Number of line being currently processed
		</td>
		<td class="noborder left">
			<a href="#FILBUF">FILBUF</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LOG>
			LOG
		<td class="noborder left">
			Not now used
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=LOKTYP>
			LOKTYP
		<td class="noborder left">
			Space reserved for unstack in <a href="#TYPBOX">TYPBOX</a>
		<td class="noborder left">
			<a href="#UNSTAK">UNSTACK</a> <a href="#STEP">STEP</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=M>
			M<br><br>
		<td class="noborder left">
			0 if delimiter only; 1 if identifier delimiter;<br>
			2 if constant delimiter
		<td class="noborder left">
			<a href="#IDENT">IDENT</a> <a href="#NUMBER">NUMBER</a><br>
			<a href="#END">END</a> <a href="#BCR">BCR</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=MFAIL>
			MFAIL
		<td class="noborder left">
			Records a failure
		<td class="noborder left">
			<a href="#FAIL>FAIL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=MPRINT">
			MPRINT<br>
		<td class="noborder left">
			Set in print statement<br>
		<td class="noborder left">
			<a href="#PRINT">PRINT</a> <a href="#LSBRAK">LSBRAK</a><br>
			<a href="#LRBRAK">LRBRAK</a> <a href="#ENDSTA">ENDSTA</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=READ">
			MREAD<br>
		<td class="noborder left">
			Set in print statement<br>
		<td class="noborder left">
			<a href="#READ">READ</a> <a href="#LSBRAK">LSBRAK</a><br>
			<a href="#LRBRAK">LRBRAK</a> <a href="#ENDSTA">ENDSTA</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=NAM>
			NAM
		<td class="noborder left">
			Contains current (or last) identifier
		<td class="noborder left">
			<a href="#IDENT">IDENT</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=NDAP>
			NDAP
		<td class="noborder left">
			Notional data area pointer
		<td class="noborder left">
			<a href="#START">START</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=NLP>
			NLP<br><br><br><br>&nbsp;
		<td class="noborder left">
			Name list pointer<br><br><br>
			NLP+1 Initial value of NLP (7995)<br>
			NLP+2 value of NLP after 1st block
		<td class="noborder left">
			<a href="#START">START</a> <a href="#NCLAPS">NCLAPS</a><br>
			<a href="#SEARCH">SEARCH</a> <a href="#DEC">DEC</a><br>
			<a href="#PROCED">PROCED</a> <a href="#FCLAPS">FCLAPS</a><br>
			<br>
			<a href="#NCLAPS">NCLAPS</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=OPTION>
			OPTION
		<td class="noborder left">
			Parameter of translation
		<td class="noborder left">
			<a href="#START">START</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=OWNCOD>
			OWNCOD
		<td class="noborder left">
			Set for owncode procedures
		<td class="noborder left">
			<a href="#PROCED">PROCED</a> <a href="#CODE">CODE</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=P>
			P<br>
		<td class="noborder left">
			Parameter for checking validity of some subroutine
			calls
		<td class="noborder left">
			<a href="#BCR">BCR</a> <a href="#EXP">EXP</a><br>
			&nbsp;&nbsp;<a href="#TAKE">TAKE</a> <a href="#DEC">DEC</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PARAM>
			PARAM
		<td class="noborder left">
			Not now used
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PH>
			PH
		<td class="noborder left">
			Procedure heading
		<td class="noborder left">
			<a href="#PROCED">PROCED</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PP>
			PP
		<td class="noborder left">
			Current value of pord pointer
		<td class="noborder left">
			<a href="#COMPIL">COMPIl</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PRCENT>
			PRCENT
		<td class="noborder left">
			Temporary storage for found entry in Name list
		<td class="noborder left">
			<a href="#PROCED">PROCED<a/>
	</tr>
</table>

<br clear=left>

<p>
	<a href="Description Pages/page34.jpg">[PAGE -31-]</a>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder left" style="width:10ch"><u>Variable</u></td>
		<td class="noborder center" style="width:36ch"><u>Use</u></td>
		<td class="noborder left" style="width:21ch"><u>Set in</u></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder left" id=PROC>
			PROC<br><br>
		<td class="noborder left">
			Set in procedures<br><br>
		</td>
		<td class="noborder left">
		<a href="#PROCED">PROCED</a> <a href="#LRBRAK">LRBRAK</a><br>
		<a href="#LSBRAK">LSBRAK</a> <a href="#QUOTE">QUOTE</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PROCPO>
			PROCPO
		<td class="noborder left">
			Pointer to procedure name in actual call
		</td>
		<td class="noborder left">
			<a href="#LRBRAK">LRBRAK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=PRMCOU>
			PRMCOU<br>
		<td class="noborder left">
			Number of current parameter<br>

		</td>
		<td class="noborder left">
			<a href="#PROCED">PROCED</a><br>
			<a href="#RRBRAK">RRBRAK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="Q">
			Q
		<td class="noborder left">
			Used to search constants area
		</td>
		<td class="noborder left">
			<a href="#SECODL">SECODL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="R">
			R
		<td class="noborder left">
			Not now used
		</td>
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="REL">
			REL
		<td class="noborder left">
			Not now used
		</td>
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="SP">
			SP
		<td class="noborder left">
			Stack pointer
		</td>
		<td class="noborder left">
			<a href="#RESTO">RESTO</a> <a href="#STACK>STACK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="SPR">
			SPR
		<td class="noborder left">
			Stack priority
		</td>
		<td class="noborder left">
			<a href="#UNSTACK>UNSTACK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="SV">
			SV<br>&nbsp;
		<td class="noborder left">
			Variable to denote where an array element
			is syntactically <red>valid</red>.
		</td>
		<td class="noborder left">
			<a href="#ENDSTA">ENDSTA</a> <a href="#GOTO">GOTO</a><br>
			<a href="#BECOMS">BECOMS</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="TS">
			TS
		<td class="noborder left">
			Top of stack
		</td>
		<td class="noborder left">
			<a href="#RESTO">RESTO</a> <a href="#STACK">STACK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="TYPBOX">
			TYPBOX<br>&nbsp;
		<td class="noborder left">
			Type of current Algol section<br>&nbsp;
		</td>
		<td class="noborder left">
			<a href="#SEARCH">SEARCH</a> <a href="#UNSTAK">UNSTAK</a>
			<a href="#LSBRAK">LSBRAK</a><br>
			<a href="#TAKID">TAKID</a> <a href="#TAKE">TAKE</a>
			<a href="#TYPCHK">TYPCHK</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="TYPE">
			TYPE
		<td class="noborder left">
			Not now used
		</td>
		<td class="noborder left">
			&nbsp;
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="WANTED">
			WANTED
		<td class="noborder left">
			Marker to show whether a library function is wanted
		</td>
		<td class="noborder left">
			<a href="#FOMPIL">FOMPIL</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id=WM>
			WM<br>
			&nbsp;
		<td class="noborder left">
			Warning marker<br>
			&nbsp;
		</td>
		<td class="noborder left">
			<a href="#FCLAPS">FCLAPS</a> <br>
			<a href="#NCLAPS">NCLAPS</a> <a href="#END">END</a>
	</tr>
	<tr>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
		<td class="noborder">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder left" id="XX">
			XX<br>&nbsp;
		<td class="noborder left">
			Used for checking validity of , and : in
			array declarations
		</td>
		<td class="noborder left">
			<a href="#ARRBND">ARRBND</a> <br>
			&nbsp;
		</td>
	</tr>
</table>

<br clear=left>

<p>
	<a href="Description Pages/page35.jpg">[PAGE -32-]</a>
</p>

<p id="LISTING">
	9.&nbsp;&nbsp;&nbsp;<u>Notes on Translator listing</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">
			(i)
		</td>
		<td class="noborder">
			<u>Location of entities</u>
			<br><br>
			An entity can be located in the listing by
			bearing in mind the Group to which it belongs.
			There are four groups -
			<br><br>
			<table class="noborder">
				<tr>
					<td class="noborder" style="width:17ch">
						Vol 1 has Group 1
					</td>
					<td class="noborder">
						All global variables
						<br>
						Code conversion table
						<br>
						Basic routines like PRINT and GETCHA
					</td>
				</tr>
				<tr><td class="noborder" colspan=2>&nbsp;</td></tr>
				<tr>
					<td class="noborder">
						Vol 2 has Group 2
					</td>
					<td class="noborder">
						Routines such as COMPIL
						which use Group 1 routines
					</td>
				</tr>
				<tr><td class="noborder" colspan=2>&nbsp;</td></tr>
				<tr>
					<td class="noborder">
						Vol 2 has Group 3
					</td>
					<td class="noborder">
						Routines such as DECL which
						use Group 2 routines.
					</td>
				</tr>
				<tr><td class="noborder" colspan=2>&nbsp;</td></tr>
				<tr>
					<td class="noborder">
						Vol 3 has Group 4
					</td>
					<td class="noborder">
						A routine for each delimiter e.g. <u>array</u>
						SIMICO etc.
					</td>
				</tr>
				<tr><td class="noborder" colspan=2>&nbsp;</td></tr>
				<tr>
					<td class="noborder" colspan=2>
						Within each group the order is alphabetical as
						far as possible. At the end of the whole
						translator is the Central Loop in order that
						jumps to delimiter routines can be to located
						places rather than forward jumps, This ordering
						helps to shorten the relocatable binary tape.
					</td>
				</tr>
				<tr><td class="noborder" colspan=2>&nbsp;</td></tr>
			</table>
		</td>
	</tr>
	<br>
	<tr>
		<td class="noborder">
			(ii)
		</td>
		<td class="noborder">
			<u>Assembly</u>
			<br>
		</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">
			<ol>
				<li>
					Assemble using 6th April 1966 SIR to a
					relocatable binary tape.
					<br><br>
				</li>
				<li>
					Input this tape which produces a global.
					label list, and also records the store
					used.
					<br><br>
				</li>
				<li>
					Clear locations 6000-8178 so as to remove
					the loader.
					<br><br>
				</li>
				<li>
					Input the initial names list in binary which
					occupies from 7800 approximately to 7998.
					<br><br>
				</li>
				<li>
					Dump the store using "Larry T22".
					<br><br>
				</li>
					Attach a clear stores (or punch it in) at
					the front.
				</li>
			</ol>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			(iii)
		</td>
		<td class="noborder">
			<u>Initial Names list</u>
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">
			The initial names list must be assembled using
			a version of SIR in 2048. After assembly clear
			locations 8-7168 to remove SIR and then dump
			the store using Larry T22.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page36.jpg">[PAGE -33-]</a>
</p>

<p class="center" id="CENTRAL">
	<u>CENTRAL LOOP</u>
</p>

<p class="indent">
	The basic cycle routine (<a href="#BCR">BCR</a>) fetches the next
	ALGOL "section", which is in one of the following three
	formats, and sets the variable <a href="#M">M</a> to be
</p>

<table class="noborder margin3t">
	<tr>
		<td class="noborder">O :</td>
		<td class="noborder"> delimiter by itself</td>
	</tr>
	<tr>
		<td class="noborder">1 :</td>
		<td class="noborder">identifier followed by delimiter</td>
	</tr>
	<tr>
		<td class="noborder">2 :</td>
		<td class="noborder">constant followed by delimiter</td>
	</tr>
</table>

<p class="indent">
	A delimiter being a basic symbol like 3 or +, or
	an ALGOL word like <u>begin</u>.
</p>

<p class="indent">
	Depending upon the delimiter discovered, a transfer
	of control is made to the relevant routine, which will
	end with a jump back to <a href="#OUT">OUT</a>. In some cases <a href="#BCR">BCR</a> is called
	during the routines (e.g. in <u>procedure</u> it is called to
	check whether the procedure body is in ALGOL or in own
	code) and in these cases exit is made back to <a href="#OUT2">OUT2</a>, and
	processing continues on that delimiter.
</p>

<p class="indent">
	<a href="#BCR">BCR</a> is called with one parameter which can be either
	0, 1, 2, 3 or 4. The first three require the section
	to comply with this forecast for <a href="#M">M</a>. <a href="#BCR">BCR</a> (3) is the general
	call which will accept any section, and <a href="#BCR">BCR</a> (4) is the
	call during subsequent discarding of the rest of an erroneous statement or
	declaration, or of a comment.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;33</td>
		<td class="noborder">
			) or ] precedes constant or identifier
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;10</td>
		<td class="noborder">
			<a href="#M">M</a> doesn't agree with the parameter in <a href="#BCR">BCR</a> (0, 1 or 2)
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;11</td>
		<td class="noborder">
			Alphanumeric character, '.' or <sub>10</sub> misplaced.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;12<td class="noborder">
			Constant or identifier <u>true</u> <u>false</u>
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;13</td>
		<td class="noborder">
			<u>comment</u> misplaced
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;15</td>
		<td class="noborder">
			Unrecognised underlined word.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page37.jpg">[PAGE -34-]</a>
</p>

<p class="center" id="FAIL">
	<u>FAIL</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/FAIL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FAIL">[Code]</a>
</p>

<p class="indent">
	This routine is accessed whenever a failure occurs
	which doesn't make continuation impossible, <a href="#N">N</a>.B. If
	the stack Pointer moves beyond the beginning of the
	stack this is considered impossible and the program
	jumps straight to <a href="#ENDPRO">ENDPRO</a>. In general, the action taken
	is to throw away the remainder of the statement.
</p>

<p class="indent">
	First the error message is printed which gives the
	error number, line number, line stored in <a href="#INBUF">INBUF</a> and a
	pointer which shows which is the offending character
	(except in the case of an illegal character when the
	whole buffer is inspected and illegal characters replaced
	by ? or &larr; (westrex). The: error count is incremented
	and the program terminates if it reaches 20. The option
	is inspected and set to checking mode, followed by a pause
	in the 'halt on error' condition. It is here that a
	return is then made to <a href="#NCLAPS">NCLAPS</a> if an unallocated label
	has been found, otherwise the stack is cleared back to
	a begin, and the global variables are reset.
</p>

<p class="indent">
	The current delimiter is then inspected. If not a ;,
	<u>end</u> or <u>begin</u>, the next ALGOL section is brought in to
	replace it, and this is repeated until one of these
	delimiters occurs. <a href="#FAIL">FAIL</a> then exits to either the routine
	<a href="#BEGIN">BEGIN</a>, or internally to <a href="#END">END</a> or <a href="#SEMICO">SEMICO</a> unless the text
	is found to be inside a procedure heading when the rest
	of the heading is discarded before processing.
</p>

<p>
	<a href="Description Pages/page38.jpg">[PAGE -35-]</a>
</p>

<p id="TAKCHA" class="center">
	<u>TAKCHA</u> (<u>Take Character</u>)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/TAKCHA.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_TAKCHA">[Code]</a>

<p class="indent">
	This subroutine, called from <a href="#BCR">BCR</a>, places the next
	significant character in the source line into the global
	variable space. The current character is moved to
	<a href="#LASTCH">LASTCH</a>, the character just received is put to LASTCH+2
	for the 'look ahead' facility, while the character currently
	there becomes the present character to be processed, and
	moves to LASTCH+1, "space" or "tab" are ignored; "newline"
	replenishes the source line in the buffer by the use of the
	subroutine <a href="#FILBUF">FILBUF</a>.
</p>

<p class="indent">
	The only characters requiring further study are :
	and ). The former may be followed by = to produce :=,
	and the tests on this branch are used to ascertain whether
	this is the case.
<p>

<p class="indent">
	The latter, closing round bracket, may be the start
	of a comment acting as an actual parameter delimiter.
</p>

<p class="indent">E.G:</p>

<p class="margin1">
	PROCCALL (a) this is a comment ; (b);
	<br>
	&nbsp;&nbsp;&nbsp;is the equivalent of PROCCALL (a,b);
</p>

<p class="indent">
	<a href="#PROC">PROC</a> is tested to see whether we are dealing with
	a procedure call, and if so, the next character in the
	line is tested to see if it is a letter. This
	differentiates between
</p>

<p class="margin1">
	&nbsp;&nbsp;&nbsp;&nbsp;PROCCALL (a) this is
	<br>
	and PROCCALL (a
</p>

<p class="indent">
	If this is a comment, the buffer is searched for the
	terminating colon ; when found, the next character is
	checked to be (, and <a href="#THISCH">THISCH</a> is set to comma (the other
	valid form of parameter delimiter).
</p>

<p class="indent">
	<u>ERRORS</u>:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder" style="width:9ch">FAIL &nbsp;56;</td>
		<td class="noborder">
			character other than separator between
			the : and ( of a parameter comment.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page39.jpg">[PAGE -36-]</a>
</p>

<p id="IDENT" class="center">
	<u>IDENTIFIER</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/IDENT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_IDENT">[Code]</a>
</p>

<p class="indent">
	This routine merely builds up the identifier character
	by character in the state variable <a href="#NAM">NAM</a>, ignoring any
	 significant character after the sixth (an <a href="#IFIP">IFIP</a> ALGOL subset
	restriction).
</p>

<p class="indent">
	It is called from <a href="#BCR">BCR</a> when the next character is found
	to be alphabetic, and reads characters storing them in the
	most significant end of the double length pair <a href="#NAM">NAM</a> and
	<a href="#NAM">NAM</a> +1, It sets <a href="#M">M</a> to 1 and exits when a delimiter is
	found.
</p>

<p>
	<a href="Description Pages/page40.jpg">[PAGE -37-]</a>
</p>

<p id="EVALNA" class="center">
	<u>EVALNA</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/EVALNA.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_EVALNA">[Code]</a>
</p>

<p class="indent">
	This subroutine, called from <a href="#BCR">BCR</a>, converts a
	delimiter such as ~begin~ into an integer. The
	routine clears a location then adds successive characters
	to it multiplying each intermediate result by 67. When
	the closing character is met, the result is looked up in
	a table and replaced by the required delimiter.
</p>

<p class="indent">
	<u>ERROR</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;15;</td>
		<td class="noborder">
			Unrecognised result after this evaluation.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page41.jpg">[PAGE -38-]</a>
</p>

<p class="center" id="NUMBER">
	<u>NUMBER</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/NUMBER.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_NUMBER">[Code]</a>
</p>

<p class="indent">
	This subroutine (written by <a href="#C">C</a>.W. Nott of <a href="#N">N</a>,P.L)
	ends by placing the binary equivalent of the decimal
	digits in the state variable <a href="#CONSTA">CONSTA and CONSTA+1</a>.
</p>

<p class="indent">
	This routine calls its own local routines; <a href="#STAND">STAND</a>
	which standardises the floating point number in W3 and
	W4 (binary exponent in W5); <a href="#POWER">POWER</a> which multiplies the
	number by the accumulator to the power of 10. Bearing
	in mind also the uses of the variable space (below) the
	routine should be clear from the flowchart,
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">
			<a href="#LASTCH">LASTCH</a>
		</td>
		<td class="noborder">
			last character read.
		</td>
	</tr>
	<tr>
		<td class="noborder">
			Sign
		</td>
		<td class="noborder">
			set to one if the exponent part
			is negative.
		</td.
	</tr>
	<tr>
		<td class="noborder">
			W3,&nbsp;4&nbsp;&&nbsp;5
		</td>
		<td class="noborder">
			used for the partially computed
			number.
		</td>
	</tr>
	<tr>
		<td class="noborder">
			Exp
		</td>
		<td class="noborder">
			set to one by the character ''<sub>10</sub>'
		</td>
	</tr>
	<tr>
		<td class="noborder">
			Point
		</td>
		<td class="noborder">
			set to one by the character '.'
		</td>
	</tr>
	</tr class="noborder">
		<td class="noborder">
			Dec
		</td>
		<td class="noborder">
			used to count the number of
			decimal places and for any
			exponent,
		</td>
	</tr>
	<tr>
		<td class="noborder">
			Max
		</td>
		<td class="noborder">
			set to one if the integer or
			exponent part of the number
			exceeds capacity.
		</td>
	</tr>
	<tr>
		<td class="noborder">
			PWS
		</td>
		<td class="noborder">
			parameter for <a href="#POWER">POWER</a>
		</td>
	</tr>
	<tr>
		<td class="noborder">
			PMKR
		</td>
		<td class="noborder">
			marker to remember whether this
			power was negative or not.
		</td>
	</tr>
</table>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;&nbsp;7;</td>
		<td class="noborder">
			illegal number
		</td>
	</tr>
	<tr calss="noborder">
		<td class="noborder">FAIL &nbsp;&nbsp;8;</td>
		<td class="noborder">
			number too big.
		</td>
	</td>
</table>

<p>
	<a href="Description Pages/page42.jpg">[PAGE -39-]</a>
</p>

<p id="BCR" class="center">
	<u>BASIC CYCLE ROUTINE (BCR)</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/BCR.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_BCR">[Code]</a>
</p>

</p>
	This subroutine is used to fetch the next section
	of ALGOL text, and to allow for comments after the
	delimiters ; and begin. It is controlled by its
	parameter <a href="#P">P</a> as follows:
<p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">(1)</td>
		<td class="noborder">
			<a href="#P">P</a> = 0, 1, or 2: a certain type of ALGOL
			section is expected, and this is checked by
			comparing the final value of the state
			variable <a href="#M">M</a> ;
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			<a href="#P">P</a> = 3 : no check is made on the type of
			the ALGOL section; and
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">
			<a href="#P">P</a> = 4 ; the subroutine is merely being
			used to find the next delimiter, such as
			in an end comment, or during scanning
			after an error (see <a href="#FAIL">FAIL</a>). The
			constituents of identifiers and numbers
			need not therefore be processed.
		</td>
	</tr>
<table>

<p class="indent">
	<a href="#BCR">BCR</a> itself uses several subroutines, First it
	calls <a href="#TAKCHA">TAKCHA</a>, which brings up the next character which
	is tested to distinguish between delimiters, numbers and
	identifiers.
</p>

<p class="indent">
	A ~ (or " in 903 ALGOL) announces an ALGOL word
	(see Notes on Internal Character Set), such as ~begin~.
	This is operated upon by the subroutine <a href="#EVALNA">EVALNA</a> to convert
	the string of characters into an integer, and the delimiter
	list is then searched. If the delimiter is <u>comment</u>, further
	characters are taken <a href="#UNTIL">UNTIL</a> ; is met, which ends the comment.
	If the delimiter is <u>true</u> or <u>false</u> <a href="#CONS">CONS</a>,
	<a href="#M">M</a>, and <a href="#CONSTA">CONSTA</a> are
	set. Otherwise this joins the basic symbol path.
</p>

<p class="indent">
	If this character is a basic symbol, the symbol list
	is searched, <a href="#P">P</a> is checked where necessary and the routine
	finishes.
</p>

<p class="indent">
	If this character is a digit, decimal point or 10,
	<a href="#NUMBER">NUMBER</a> is called to place this number in the variable
	<a href="#CONSTA">CONSTA</a>.
</p>

<p class="indent">
	Similarly in the case of a letter, <a href="#IDENT">IDENT</a> is called to
	place this identifier in the variable <a href="#NAM">NAM</a>.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;13;
			<br><br>
		</td>
		<td class="noborder">
			<u>comment</u> does not follow follow ; or <u>begin</u>.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;11;
			<br><br>
		</td>
		<td class="noborder">
			letter, digit, '.' or ''<sub>10</sub>' misused.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;10;
			<br><br>
		</td>
		<td class="noborder">
			identifier or constant not as expected.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;12;
			<br><br>
		</td>
		<td class="noborder">
			<u>true </u>or <u>false</u> preceded by constant or
			identifier.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;33;
			<br><br>
		</td>
		<td class="noborder">
			 ] or ) precedes constant or identifier.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;15;
			<br><br>
		</td>
		<td class="noborder">
			unrecognised ALGOL word (<a href="#EVALNA">EVALNA</a>).
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page43.jpg">[PAGE -40-]</a>
</p>

<p id="UNSTAK" class="center">
	<u>UNSTAK</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/UNSTAK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_UNSTAK">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to unstack items from the top
	of the stack <a href="#UNTIL">UNTIL</a> an item is reached whose stack priority
	is less than the value given by the parameter, or
	<a href="#UNTIL">UNTIL</a> the stack is empty. In general, items are unstacked
	directly into the object program (in some cases after
	extensive typechecking) with the following exceptions:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">
			If the stack priority <a href="#SPR">SPR</a> of the current
			item is 12, the variable <a href="#P">P</a> (set up by
			<a href="#TAKE">TAKE</a> or <a href="#EXP">EXP</a>) determines whether to
			generate INDA or INDR.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			If the <a href="#SPR">SPR</a> of the current item is 8 (i.e. it is a relational operator)
			the parameter should not be 8 as this would mean an incorrect use of
			relational operators, e.g:
			<p class="margin3">
				x &lt; y + z &lt; 4
			</p>
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">
			If the top of the stack is else <a href="#E">E</a>, <a href="#TYPBOX">TYPBOX</a>
			and <a href="#LOKTYP">LOKTYP</a> must be checked to produce the
			special case:
			<p class="margin3">
				UJ PP+2
				<br>
				Update <a href="#ADDRES">ADDRES</a>
				<br>
				I&rarr;R1
				<br><br>
				when <a href="#LOKTYP">LOKTYP</a> is zero and the else part turns out to be real. (This is a
				consequence of the single pass technique).
		</td>
	</tr>
	<tr>
		<td class="noborder">(iv)</td>
		<td class="noborder">
			Another special case is where the delimiter
			from the stack is :=, the necessary conversion
			may be R&rarr;I if the left hand side is integer.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(v)</td>
		<td class="noborder">
			Where the delimiter from the stack is an
			arithmetic or relational operator, further
			typechecking is necessary, and special
			primitives may be compiled, as in the cases of
			integer&uarr;2 or Real&uarr;integer.
			<br><br>
		</td>
	</tr>
</table>

<p class="indent">
	<u>ERRORS</u>
	</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;34;</td>
		<td class="noborder">
			incorrect use of relational operator.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;64;</td>
		<td class="noborder">
			illegal use of subscript variable.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 104;</td>
		<td class="noborder">
			<u>Div</u> has real operand.
			<br><br>
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page44.jpg">[PAGE -41-]</a>
</p>

<p id="EXP" class="center">
	<u>EXP</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/EXP.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_EXP">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to check the validity of use
	of the current delimiter and to change the state variable
	<a href="#E">E</a> to expression level if necessary.
</p>

<p class="indent">
The parameter <a href="#P">P</a> has the following meaning:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(1)</td>
		<td class="noborder">P = 1</td>
		<td class="noborder">
			Delimiter can only be used at expression level.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">P = 2</td>
		<td class="noborder">
			Delimiter can only be used at statement level.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">P = 3</td>
		<td class="noborder">
			Delimiter can be used at either
			level.
		</td>
	</tr>
</table>

<p class="indent">
	<a href="#UNSTAK">UNSTAK</a> is called with a parameter of 12 to unstack
	IND (the parameter <a href="#P">P</a> deciding whether INDA or INDR is to
	be generated), and the top of the stack tested to see
	whether := necessitates a changing of <a href="#E">E</a> to zero, Logical,
	arithmetic and relational operators in statements other than
	procedure calls are failed here.
</p>

<p class="indent">
	<u>ERRORS</u>:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;35;</td>
		<td class="noborder">
			illegal statement ~ delimiter misused.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;55;</td>
		<td class="noborder">
			<u>go</u> <u>to</u>, : or <u>for</u> used in expression.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page45.jpg">[PAGE -42-]</a>
</p>

<p id="PRAMCH" class="center">
	<u>PRAMCH</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/PRAMCH.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PRAMCH">[Code]</a>
</p>

<p class="indent">
	This subroutine is called from <a href="#ACTOP">ACTOP</a> to check the actual
	parameter with the correcponding formal parameter and to
	compile the relevant object program operation which will
	access this actual parameter for the procedure that is
	being called.
</p>

<p class="indent">
	TABLE 1 gives a list of formal parameter types
	with the possible actual paramete types. In general,
	the rules are :-
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">
			If the <a href="#F">F</a>.p. is called by name, the a.p. must
			have the same type and kind.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			If the f.p. is a scalar called by value, the
			actual parameter may be a scalar, expression,
			array subscript, constant or type procedure
			call.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">
			If the f.p. is a label called by value, the
			actual parameter may be a label or switch
			subscript<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">(iv)</td>
		<td class="noborder">
			Procedures, strings and switches and parameters
			of formal procedures may be called by name only.
		</td>
	</tr>
</table>

<p class="indent">
	The choice is further complicated, in the case of
	scalars, by the fact that an actual parameter may itself
	be a formal parameter. Table 2 gives the possibilities
	for this case.
</p>

<p class="indent">
	The subroutine uses the following variables:-
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder"><a href="#PROCPO">PROCPO ;</a></td>
		<td class="noborder">
			Namelist address of procedure using
			this actual parameter.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder"><a href="#PRMCOU">PRMCOU</a> ;</td>
		<td class="noborder">
			number of actual parameter in the
			procedure call.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder"><a href="#I">I</a> ;</td>
		<td class="noborder">
			namelist address of actual parameter.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder"><a href="#TYPBOX">TYPBOX</a> ;</td>
		<td class="noborder">
			expression type (real or integer)
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">V ;</td>
		<td class="noborder">
			<a href="#O">O</a> if called by name, 1 if called by
			value.
		</td>
	</tr>
</table>

<p class="indent">
	The first job of <a href="#PRAMCH">PRAMCH</a> is to recognise whether the
	parameter is of a formal procedure or not, then <a href="#W">W</a> locations
	7 to 10 are set up the formal entry, <a href="#V">V</a> formal, type of
	formal and type difference (actual type - formal type).
	Next in the cases <a href="#PRAMCH">PRAMCH</a> (0) and <a href="#PRAMCH">PRAMCH</a> (3) when parameter
	checking words are compiled W14 is set with the check word,
	then W11 is set with a bit pattern according to W7, the
	formal entry, which later helps with the processing of
</p>

<p>
	<a href="Description Pages/page46.jpg">[PAGE -43-]</a>
</p>

<p>
	identifiers, non-formal function designators and array
	subscripts.
</p>

<p class="indent">
	Little remains now except the somewhat tedious syntatical checking and to compile
	the parameter call. After
	this is compiled the parameter checking word if applicable
	and the routine exits to ) or comma.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL &nbsp;&nbsp;5;</td>
		<td class="noborder">
			fp is not label when ap is a switch	subscript.
			<br>
			fp is not called by value when ap is a switch subscript.
			<br>
			fp is not scalar when ap is procedure call or array subscript.
			<br>
			fp is not scalar when ap is expression.
			<br>
			fp is not called by value when ap is expression.
			<br>
			ap is integer constant when fp is non integer by name,
			<br>
			ap is Boolean constant when fp is non Boolean
			<br>
			ap is real constant when fp is non real by name.
			<br>
			ap is wrong type array when fp is array by value.
			<br>
			illegal ap called by value.
			<br>
			ap is not label when fp is label by value.
			<br>
			ap is not Boolean when fp is Boolean scalar.
			<br>
			wrong type of formal parameter.
			<br>
			scalar used as ap when fp is called by value.
			<br>
			wrong type of formal parameter used as ap when fp is not scalar.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder" style="width:9ch">FAIL &nbsp;51;</a></td>
		<td class="noborder">
			too many actual parameters.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;94;</td>
		<td class="noborder">
			unrecognised formal type.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 108;</td>
		<td class="noborder">
			parameter of formal procedure called by value.
		</td>
	</tr>
</table>
<p>
	<a href="Description Pages/page47.jpg">[PAGE -44-]</a>
</p>

<p class="margin1">
	<u>TABLE 1</u>
</p>

<table class="noborder margin0t" style="width:20cm">
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder">F.P.</td>
		<td class="noborder">Actual Parameter</td>
		<td class="noborder">
			Formal
			<br>
			Parameter
		</td>
		<td class="noborder center">
			Name
			<br>
			or Value
		</td>
		<td class="noborder">Actual Parameter Operation</td>
	</tr>
	<tr>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder"><u>scalar</u></td>
		<td class="noborder">Integer Identifier/constant</td>
		<td class="noborder">Integer</td>
		<td class="noborder center">N )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">Real</td>
		<td class="noborder center">N )</td>
		<td class="noborder">Take address of</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">Boolean</td>
		<td class="noborder center">N )</td>
		<td class="noborder">Take constant address</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>array</u></td>
		<td class="noborder">Integer array</td>
		<td class="noborder">Integer array</td>
		<td class="noborder center">N )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder center">N )</td>
		<td class="noborder">Take address of array map</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean&nbsp;&nbsp;"</td>
		<td class="noborder">Boolean&nbsp;&nbsp;"</td>
		<td class="noborder center">N )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>procedure</u></td>
		<td class="noborder">Blank procedure</td>
		<td class="noborder">Blank<br>&nbsp;&nbsp;&nbsp;procedure</td>
		<td class="noborder center"><br>N )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Integer&nbsp;&nbsp;"</td>
		<td class="noborder">Integer&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder center">N )</td>
		<td class="noborder">Take address of</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder center">N )</td>
		<td class="noborder">block</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean&nbsp;&nbsp;"</td>
		<td class="noborder">Boolean&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder center">N )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>switch</u></td>
		<td class="noborder">Switch</td>
		<td class="noborder">Switch</td>
		<td class="noborder center">N&nbsp;&nbsp;</td>
		<td class="noborder">Take constant area address</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>string</u></td>
		<td class="noborder">String</td>
		<td class="noborder">String</td>
		<td class="noborder center">N&nbsp;&nbsp;</td>
		<td class="noborder">Take address of actual string</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>label</u></td>
		<td class="noborder">Label</td>
		<td class="noborder">Label</td>
		<td class="noborder center">N&nbsp;&nbsp;</td>
		<td class="noborder">Take label address</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Label</td>
		<td class="noborder">Label</td>
		<td class="noborder center">V&nbsp;&nbsp;</td>
		<td class="noborder">Take label address</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Switch subscript</td>
		<td class="noborder">Label</td>
		<td class="noborder center">V&nbsp;&nbsp;</td>
		<td class="noborder">Index label address (INDS)</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>array</u></td>
		<td class="noborder">Integer array</td>
		<td class="noborder">Integer array</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Take address of array map</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder">Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder center">V )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean&nbsp;&nbsp;"</td>
		<td class="noborder">Boolean&nbsp;&nbsp;"</td>
		<td class="noborder center">V )</td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u>scalar</u></td>
		<td class="noborder">Integer Identifier/constant</td>
		<td class="noborder">Integer</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Take value and comnpile type</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			Real&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">Real</td>
		<td class="noborder center">V )</td>
		<td class="noborder">conversion if necessary</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">Boolean</td>
		<td class="noborder center">V&nbsp;&nbsp;</td>
		<td class="noborder">Take value</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page48.jpg">[PAGE -45-]</a>
</p>

<p class="margin1">
	<u>TABLE 2</u>
</p>

<table class="noborder margin0t" style="width:20cm">
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		</td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class="noborder">F.P.</td>
		<td class="noborder">Actual Parameter</td>
		<td class="noborder">
			Formal
			<br>
			Parameter
		</td>
		<td class="noborder center">
			Name
			<br>
			or Value
		</td>
		<td class="noborder">Actual Parameter Operation</td>
	</tr>
	<tr>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
		<td class="noleftborder norightborder notopborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noborder"><u>scalar</u></td>
		<td class="noborder">expression</td>
		<td class="noborder">(Integer</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Compile type conversion if</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder">(Real</td>
		<td class="noborder center">V )</td>
		<td class="noborder">necessary.</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;"</td>
		<td class="noborder">(Boolean</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Take value</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Integer/real identifier</td>
		<td class="noborder">(Integer</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Take value and compile type</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">(Real</td>
		<td class="noborder center">V )</td>
		<td class="noborder">necessary.</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean identifier</td>
		<td class="noborder">Boolean</td>
		<td class="noborder center">V&nbsp;&nbsp;</td>
		<td class="noborder">Take value</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"><u></u></td>
		<td class="noborder">Integer/Real array subscript</td>
		<td class="noborder">(Integer</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Take value and compile type</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">(Real</td>
		<td class="noborder center">V )</td>
		<td class="noborder">necessary.</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean array subscript</td>
		<td class="noborder">Boolean</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Index value.</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
		<td class="noborder"></td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Integer/Real procedure call</td>
		<td class="noborder">(Integer)</td>
		<td class="noborder center">V )</td>
		<td class="noborder">Compile type conversion</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">
			&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
		</td>
		<td class="noborder">(Real)</td>
		<td class="noborder center">V )</td>
		<td class="noborder">if necessary.</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">Boolean procedure call</td>
		<td class="noborder">Boolean</td>
		<td class="noborder center">V&nbsp;&nbsp;</td>
		<td class="noborder"></td>
	</tr>
</table>

<p>
	<a href="Description Pages/page49.jpg">[PAGE -46-]</a>
</p>

<p>
	<u>Actual Parameters which are Formal Parameter Scalars
	<br>
	<br>
	Example</u>
</p>

<pre class="courier margin1">
<u>real</u> <u>procedure</u> P (t) ; <u>value</u> t; <u>integer</u> t;
   <u>begin</u> <u>real</u> R;
    R := t</u>
    <u>end</u>
     .
     .
     .
    <u>procedure</u> Q (a,b,c); <u>value</u> a; <u>integer</u> a,b; <u>real</u> c;
    <u>begin</u> <u>real</u> Y;
       Y := P (a) +P (b) + P (c);
    <u>end</u>
     ;
     .
     .
Q  (JIM, FRED, BILL) ;
</pre>

<p class="indent">
	The call of procedure Q with actual parameters JIM,
	FRED and BILL will give value, address, address on the
	stack since the formal parameters are value a, name b,c.
	However, the procedure P expects an integer value on the
	stack, since its formal parameters t is called by value.
	So the final two parameters are called by Take Formal
	Value which puts the result in the stack.
</p>

<p>
	In the following table of actual parameter operations,
	procedure Q would be SOURCE and procedure P would be DESTINATION.
</p>

<p>
	<u>TABLE 2</u>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="notopborder" colspan=2>SOURCE</td>
		<td class="notopborder"colspan=2>DESTINATION</td>
		<td class="notopborder">Actual Parameter operation</td>
	</tr>
	<tr>
		<td class="noleftborder norightborder nobottomborder" colspan=5>
	</tr>
	<tr>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder"> I/R</td>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder">I</td>
		<td class="notopborder nobottomborder">
			Take Formal Value. R to I if
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;necessary
		</td>
	</tr>
	<tr>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder">I/R</td>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder">R</td>
		<td class="notopborder nobottomborder">
			&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;&nbsp;"
			&nbsp;&nbsp;&nbsp;I to R&nbsp;&nbsp;"
		</td>
	</tr>
	<tr>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder"> </td>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder"></td>
		<td class="notopborder nobottomborder">
			Take Stack Address (R/IFUN) same
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type
		</td>
	</tr>
	<tr>
		<td class="notopborder nobottomborder">name</td>
		<td class="notopborder nobottomborder">I/R</td>
		<td class="notopborder nobottomborder">value</td>
		<td class="notopborder nobottomborder">R</td>
		<td class="notopborder nobottomborder">
			Take Result Call by Name
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I to R if necessary
		</td>
	</tr>
	<tr>
		<td class="notopborder">name</td>
		<td class="notopborder"> I/R</td>
		<td class="notopborder">name</td>
		<td class="notopborder"></td>
		<td class="notopborder">
			Take Formal Address same type
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page50.jpg">[PAGE -47-]</a>
</p>

<p id="SEARCH" class="center">
	<u>SEARCH</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/SEARCH.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_SEARCH">[Code]</a>
</p>

<p class="indent">
	This subroutine searches the Name List for the current
	identifier, and is called with one of four parameters:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(1)</td>
		<td class="noborder" style="width:7ch">w = 0 ;</td>
		<td class="noborder">search the entire name list and find the identifier ;</td>
	</tr>
	<tr>
		<td class="noborder">(2)</td>
		<td class="noborder">w = 1 ;</td>
		<td class="noborder">
			search the part of the name list local to this block and do not find
			the identifier;
		</td>
	</tr>
	<tr>
		<td class="noborder">(2)</td>
		<td class="noborder">w = 2 ;</td>
		<td class="noborder">
			search the part of the name list local to this block and find the identifier ;
			and
		</td>
	</tr>
	<tr>
		<td class="noborder">(4)</td>
		<td class="noborder">w = 3</td>
		<td class="noborder"> as search (1) except the identifier is then inserted.</td>
	</tr>
</table>

<p class="indent">
	In the case of w = 0, each time a block stopper is
	passed, the block number stored with it is copied into
	BN+2 (Found Block Number).
</p>

<p class="indent">
	When the identifier is found (and that is what is
	desired), it is marked as used (for later checking in
	<a href="#NCLAPS">NCLAPS</a> (COLLAPSE&#32;NAME&#32;LIST) and, where necessary, resets
	<a href="#TYPBOX">TYPBOX</a>,
	Certain checks then follow, such as, is the identifier
	preceding a [ an array or switch; is the identifier preceding
	a ( a procedure with parameters or a formal procedure zero.
</p>

<p class="margin1">
	<u>ERRORS</u>
</p>

<table class="noborder">
	<tr>
		<td class="noborder">FAIL &nbsp;48 ;</td>
		<td class="noborder">identifier declared locally.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;17 ;</td>
		<td class="noborder">identifier not declared locally.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;87 ;</td>
		<td class="noborder">identifier not switch or label when so required.</td>
	</tr>
		<td class="noborder">FAIL &nbsp;18 ;</td>
		<td class="noborder">Use of undeclared identifier.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;61 ;</td>
		<td class="noborder">( misplaced, or missing procedure name.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;99 ;</td>
		<td class="noborder">Inconsistent use of identifier.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;38 ;</td>
		<td class="noborder">[ preceded by other than switch or array.
	</tr>
</table>

<p>
	<a href="Description Pages/page51.jpg">[PAGE -48-]</a>
</p>

<p id="SECODL" class="center">
	<u>SECODL</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/SECODL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_SECODL">[Code]</a>
</p>

<p class="indent">
	This routine searches the constant area for a given constant.  The global
	 variable <a href="#Q">Q</a>
	is used to search <a href="#CODL">CODL</a>; where the constant is not found
	it is entered, updating the pointer <a href="#CODLP">CODLP</a>.
</p>

<p>
	<a href="Description Pages/page52.jpg">[PAGE -49-]</a>
</p>

<p id="TAKID" class="center">
	<u>TAKE IDENTIFIER</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/TAKID.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_TAKID">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to find the nanelist entry
	for the current identifier and to compile the correct
	object program Take Address or Take Value operation.
</p>

<p class="indent">
	The subroutine <a href="#SEARCH">SEARCH</a> fails if the identifier is
	not found in the Namelist and leaves <a href="#I">I</a> pointing to the
	entry if found. An extra check is made that an identifier
	occurring in an array declaration is non local. The
	type of the identifier is then inspected to determine which
	object program operation should be compiled.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">
			<u>switch</u> e.g. <u>go</u> <u>to</u> S [n]
			<br><br>
			No operation is required UNTIL the switch
			subscript has been processed.
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			<u>label</u> e.g. <u>go</u> <u>to</u> LABEL
			<br><br>
			GTF or GT is stacked depending on whether
			the label is a formal parameter or not,
			together with the label address from the
			namelist. This will be compiled in <a href="#UNSTAK">UNSTAK</a> at
			the end of the statement.
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">
			<u>array</u> e.g. a + arrayname [b]
			<br><br>
			Take Address or Take Formal Address is
			compiled with the address of the array map.
		</td>
	</tr>
	<tr>
		<td class="noborder">(iv)</td>
		<td class="noborder">
			<u>type procedure</u>
			<p class="margin4t">
				FUN :=
				<br>
				A := A + FUN
			</p>
			<p>
				In the former case, this is an assignment to a function
				designator shown
				by <a href="#P">P</a> = 0. If FD = 3 this assignment is
				outside the procedure body; otherwise FD is set to 1 to show the
				assignment has been made. IFUN or RFUN is compiled depending on
				whether this is an integer procedure or real procedure with no
				parameters.
			</p>
			<p>
				In the latter case, this is a function call
				shown by <a href="#P">P</a> = 1. An operation to reserve
				space for the function designator is compiled,
				followed by CFF or CI, depending on whether
				this procedure is a formal parameter or not,
				together with the object program address of
				the procedure block.
			</p>
		</td>
	</tr>
	<tr>
		<td class="noborder">(v)</td>
		<td class="noborder">
			<u>scalar</u> e.g. REAL := int + REAL
			<br><br>
			The relevant Take Address or Take Value
			operation is compiled depending on whether
			<a href="#P">P</a> = 0 or 1 and a further distinction is made
			when the variable is a formal parameter, which
			may be called by name or value (see TABLE 1).
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page53.jpg">[PAGE -50-]</a>
</p>

<p>
	<u>TABLE 1</u>
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder">P&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">f[r]</td>
		<td class="noborder">v[r]</td>
		<td class="noborder">type</td>
		<td class="noborder">Object Program Operation</td>
		<td class="noborder">&nbsp;</td>
	</tr>
	<tr>
		<td class="noleftborder norightborder notopborder" colspan=6>&nbsp;</td>
	</tr>
	<tr><td class="noborder" colspan=6>&nbsp;</td></tr>
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">0</td>
		<td class="noborder">-</td>
		<td class="noborder">Integer</td>
		<td class="noborder">Take Integer Address</td>
		<td class="noborder">TIA</td>
	</tr>
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">0</td>
		<td class="noborder">-</td>
		<td class="noborder">Real</td>
		<td class="noborder">Take Real Address</td>
		<td class="noborder">TRA</td>
	</tr>
	<tr>
		<td class="noborder">1</td>
		<td class="noborder">0</td>
		<td class="noborder">-</td>
		<td class="noborder">Integer</td>
		<td class="noborder">Take Integer Value</td>
		<td class="noborder">TIR</td>
	</tr>
	<tr>
		<td class="noborder">1</td>
		<td class="noborder">0</td>
		<td class="noborder">-</td>
		<td class="noborder">Real</td>
		<td class="noborder">Take Real Value</td>
		<td class="noborder">TRR</td>
	</tr>
	<tr><td class="noborder" colspan=6>&nbsp;</tr>
	<tr>
		<td class="noborder">0<br>0</td>
		<td class="noborder">1<br>1</td>
		<td class="noborder">0<br>0</td>
		<td class="noborder">Integer )<br>Real&nbsp;&nbsp;&nbsp;&nbsp;)</td>
		<td class="noborder middle">Take Formal Address</td>
		<td class="noborder middle">TFA *</td>
	</tr>
	<tr><td class="noborder" colspan=6>&nbsp;</td></tr>
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">1</td>
		<td class="noborder">1</td>
		<td class="noborder">Integer</td>
		<td class="noborder middle">Take Stack Integer Address</td>
		<td class="noborder middle">IFUN</td>
	</tr>
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">1</td>
		<td class="noborder">1</td>
		<td class="noborder">Real</td>
		<td class="noborder middle">Take Stack Real Address</td>
		<td class="noborder middle">RFUN</td>
	</tr>
	<tr><td class="noborder" colspan=6>&nbsp;</td></tr>
	<tr>
		<td class="noborder">1<br>1</td>
		<td class="noborder">1<br>1</td>
		<td class="noborder">0<br>0</td>
		<td class="noborder">Integer )<br>Real&nbsp;&nbsp;&nbsp;&nbsp;)</td>
		<td class="noborder middle">Integer Take Formal Value
			Indirect<br>(Take Result Call by Name
		</td>
		<td class="noborder middle">TRCN</td>
	</tr>
	<tr><td class="noborder" colspan=6>&nbsp;</td></tr>
	<tr>
		<td class="noborder">1<br>1</td>
		<td class="noborder">1<br>1</td>
		<td class="noborder">1<br>1</td>
		<td class="noborder">Integer )<br>Real&nbsp;&nbsp;&nbsp;&nbsp;)</td>
		<td class="noborder middle">Take Formal Value</td>
		<td class="noborder middle">TFV *</td>
	</tr>
</table>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder"style="width:11ch">FAIL 41 &nbsp;&nbsp;;</td>
		<td class="noborder">identifier in bound pair is local</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 22 &nbsp;&nbsp;;</td>
		<td class="noborder">
			incorrect use of label, <u>go</u> <u>to</u> obscured or
			missing.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 111 &nbsp;;</td>
		<td class="noborder">type procedure zero declared with parameters.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 46 &nbsp;&nbsp;;</td>
		<td class="noborder">
			assignment to function designator is
			outside procedure body, or assignment
			to formal procedure
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 31 &nbsp;&nbsp;;</td>
		<td class="noborder">assignment to switch</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 25 &nbsp;&nbsp;;</td>
		<td class="noborder">non type procedure as function designator</td>
	</tr>
</table>

<p>
* TFA and TFV are the same interpreter primitive.
</p>

<p>
	<a href="Description Pages/page54.jpg">[PAGE -51-]</a>
</p>

<p id="TAKE" class="center">
	<u>TAKE</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/TAKE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_TAKE">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to process an identifier or
	constant that is used in a statement or expression,
	However, if the current ALGOL section does not contain
	an identifier or constant, the last delimiter is checked,
	and if it is ] <a href="#UNSTAK">UNSTAK</a> is called to generate
	INDA or INDR as required.
</p>

<p class="indent">
	If the current ALGOL section contains an identifier,
	it is processed by the subroutine <a href="#TAKID">TAKE IDENTIFIER</a> (which
	uses the <a href="#P">P</a> which is a parameter to
	<a href="#TAKE">TAKE</a>).
</p>

<p>
	It should be noted that <a href="#P">P</a> = 1 when on the right hand
	side of an assignment statement, otherwise it is 0.
</p>

<p>
	Where the current ALGOL section contains a constant,
	<a href="#P">P</a> is checked to remove errors such as "2:=", and after
	a check that a Boolean constant is not used in an
	arithmetic expression <a href="#CODL">CODL</a> is searched, having the
	pointer <a href="#Q">Q</a> set. <a href="#CONS">CONS</a> is set by
	<a href="#BCR">BCR</a>; to zero if real, to one if integer, and to two if
	 Boolean, The test on <a href="#CONS">CONS</a> determines what instruction to generate before
	 exit.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 31;</td>
		<td class="noborder">constant before := or [</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 45;</td>
		<td class="noborder">Boolean constant cannot be used here.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 30;</td>
		<td class="noborder">adjacent delimiters inadmissible.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page55.jpg">[PAGE -52-]</a>
</p>

<p id="TYPCHK" class="center">
	<u>TYPCHK</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/TYPCHK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_TYPCHK">[Code]</a>
</p>

<p class="indent">
	This subroutine, called during a for clause, checks
	the type of the controlled variable (held in <a href="#LOKTYP">LOKTYP</a>)
	against the type of the current identifier (held in
	<a href="#TYPBOX">TYPBOX</a>). It generates a conversion if necessary, and
	resets <a href="#TYPBOX">TYPBOX</a> to the type of the controlled variable.
</p>

<p>
	<a href="Description Pages/page56.jpg">[PAGE -53-]</a>
</p>

<p id="ACTOP" class="center">
	<u>ACTOP</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/ACTOP.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ACTOP">[Code]</a>
</p>

<p class="indent">
	This subroutine is used in conjunction with <a href="#PRAMCH">PRAMCH</a>
	to check the legality of an actual parameter and to compile
	the appropriate object program instruction.
</p>

<p class="indent">
	A count of actual parameters in the current procedure
	call is kept in <a href="#PRMCOU">PRMCOU</a> which is checked, in the
	routine ')' against the number of parameters in the namelist entry
	for the procedure name.
	</p>

<p class="indent">
	If  <a href="#E">E</a> is set to expression level, this actual parameter
	could be an expression or a procedure call.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder" colspan=2><u>Example</u></td>
	</tr>
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">PROCALL (a + Q(s) + b, .......</td>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">PROCALL (a, <a href="#Q">Q</a> (s), ...........</td>
	</tr>
</table>

<p class="indent">
	The difference between these cascs is shwn by the top
	of the stack; in the latter case the top of the stack is
	'(' since each actual parameter unstacks back to the '('
	of its procedure call; in the case of an expression, the
	top of the stack will be an arithmetic, relational or
	logical operator. If this actual parameter is an expression,
	<a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a> are used to
	complete the processing of the
	preceding expression, <a href="#E">E</a> is reset to 1, and <a href="#PRAMCH">PRAMCH</a> is
	called 	to check that the corresponding formal parameter is a
	scalar called by value, and to compile a type conversion if necessary.
</p>

<p class="indent">
	If this actual parameter is a procedure call, <a href="#PRAMCH">PRAMCH</a>
	is used to check that the corresponding formal parameter
	is a scalar called by value.
</p>

<p class="indent">
	If <a href="#E">E</a> is set to statement level, the last delimiter
	(<a href="#LASTDL">LASTDL</a>) is examined to determine between the three
	possible types for this actual parameter.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder" colspan=2><u>Example</u></td>
	</tr>
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">PROCALL (a, B[1], .......LASTDEL = ]</td>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">PROCALL (a, "string", ...LASTDEL = "</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">
			PROCALL (a,b,c...........LASTDEL = ,"
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			&nbsp;
			or (
		</td>
	</tr>
</table>

<p class="indent">
	In the first case, the top of the stack is used to
	determine whether this is an array or switch subscript.
	If the former, <a href="#PRAMCH">PRAMCH</a> is used to check that the formal
	parameter is a scalar called by value, and to compile a
	type conversion if necessary. If the latter, the top of
	the stack is GTS or GTFS and <a href="#PRAMCH">PRAMCH</a> is used to check that
	the formal parameter is a label called by value.
</p>

<p class="indent">
	In the second case, <a href="#PRAMCH">PRAMCH</a> is used to check that
	the corresponding formal parameter is a string called by
	name.
</p>

<p>
	<a href="Description Pages/page57.jpg">[PAGE -54-]</a>
</p>

<p>
	<u>ACTOP (Contd)</u>
	<br><br>
</p>

<p class="indent">
	In the third case, <a href="#M">M</a> is tested to determine whether
	the actual parameter is an identifier or a constant. If
	<a href="#M">M</a> = 1, this is an identifier and the <a href="#NAMELIST">Namelist</a> is
	searched to find the declared entry. <a href="#PRAMCH">PRAMCH</a> then
	checks the type
	of the actual parameter with that of the formal parameter
	and compiles the relevant object program operations.
</p>

<p class="indent">
	If <a href="#M">M</a> = 2,this actual parameter is a constant. and
	<a href="#SECODL">SECODL</a> is used to find or enter the constant in the
	constant list, and <a href="#PRAMCH">PRAMCH</a> is used to compile the
	correct "Take constant"
	operation.
</p>

<p class="indent">
	Calls of <a href="#PRAMCH">PRAMCH</a>:
</p>

<table class="noborder">
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">Identifier</td>
	</tr>
	<tr>
		<td class="noborder">1</td>
		<td class="noborder">Constant</td>
	</tr>
	<tr>
		<td class="noborder">2</td>
		<td class="noborder">Expression</td>
	</tr>
	<tr>
		<td class="noborder">3</td>
		<td class="noborder">String</td>
	</tr>
	<tr>
		<td class="noborder">4</td>
		<td class="noborder">Switch call</td>
	</tr>
	<tr>
		<td class="noborder">5</td>
		<td class="noborder">Array subscript or procedure call.</td>
	</tr>
</table>

<p class="indent">
	<u>ERRORS</u>
</p>
<table class="noborder margin2t">
	<tr>
		<td class="noborder">FAIL 6&nbsp; ;</td>
		<td class="noborder">More than 14 parameters</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 5&nbsp; ; </td>
		<td class="noborder">Illegal actual parameter</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 49 ;</td>
		<td class="noborder">Blank parameter</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page58.jpg">[PAGE -55-]</a>
</p>

<p id="ARRAYBD" class="center">
	<u>ARRAY BD</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/ARRBND.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ARRBND">[Code]</a>
</p>

<p class="indent">
	This subroutine, called by the delimiters , and : ,
	checks the validity of their use. <a href="#TAKE">TAKE</a> and
	<a href="#UNSTAK">UNSTAK</a>
	are called to complete the processing of the preceding subscript
	bound expression, at which time the top of the stack should be
	the opening square bracket introducing the subscripts.
</p>

<p class="indent">
	If this is in an array declaration, <a href="#XX">XX</a> is used to
	check that (e.g.) :
</p>

<p class="margin2">
	<u>real</u> <u>array</u> X [a:b: .....
</p>

<p class="indent">
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is caught as illegal, and
	the count of subscripts is incremented in <a href="#DIM">DIM</a> and
	restacked.
</p>

<p class="indent">
	When this is during the use of the array, any necessary
	conversion is generated before restacking the incremented
	count of subscripts.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 66;</td>
		<td class="noborder">misused , or : in an expression.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 50;</td>
		<td class="noborder">colon in subscript expression.</td>
	</tr>
	<tr>
		<td class=noborder>FAIL 103;</td>
		<td class="noborder">commas or colons wrong in array bounds.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page59.jpg">[PAGE -56-]</a>
</p>

<p id="DEC" class="center">
	<u>DEC</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/DEC.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_DEC">[Code]</a>
</p>

<p class="indent">
	This subroutine is used by any delimiter that starts
	a declaration (e.g. <u>integer</u>); it checks the validity of
	its use and sets up a block if this is the first declaration after a
	<u>begin</u>.
</p>

<p class="indent">
	If <u>begin</u> <a href="#ALL">ALL</a> is on the top of the stack, no action
	need be taken.
	</p>

<p class="indent">
	If <u>begin</u> is top, a stopper entry is made in the
	<a href="#NAMELIST">Name List</a> and the block number updated
	(begin TR would
	have already done this). The <u>begin</u> entry is unstacked,
	and <a href="#P">P</a> tested to see if this routine has been called from
	<u>array</u>. If so, a block entry is compiled into the object
	program. <a href="#DECSTA">DECSTA</a> is set to 8&nbsp;0 before exit.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 36 &nbsp;;</td>
		<td class="noborder">declaration starts incorrectly</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 54 &nbsp;;</td>
		<td class="noborder">declaration follows statement.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 63 &nbsp;;</td>
		<td class="noborder">misplaced declarator.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page60.jpg">[PAGE -57-]</a>
</p>

<p id="DECL" class="center">
	<u>DECL</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/DECL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_DECL">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to enter all declarative
	information into the <a href="#NAMELIST">Name List</a>.
</p>

<p class="indent">
	After checking that the identifier has not already
	been declared during this block, name and type are entered.
	The parameter is then examined for the type, as follows:
</p>

<table class="noborder">
	<tr>
		<td class="noborder">0</td>
		<td class="noborder">Scalar.</td>
		<td class="noborder">Space is reserved in the notional data area,.</td>
	</tr>
	<tr>
		<td class="noborder">1</td>
		<td class="noborder">Switch.</td>
		<td class="noborder">
			Space is reserved in <a href="#CODL">CODL</a> (Constant Object Data
			Load).
		</td>
	</tr>
	<tr>
		<td class="noborder">2</td>
		<td class="noborder">Procedure.</td>
		<td class="noborder"> The current program address is inserted.</td>
	</tr>
	<tr>
		<td class="noborder">3</td>
		<td class="noborder">Array.</td>
		<td class="noborder"><a href="#ARRCOU">ARRCOU</a> is incremented.</td>
	</tr>
	<tr>
		<td class="noborder">4</td>
		<td class="noborder">Label.</td>
		<td class="noborder">
			Space is reserved in <a href="#CODL">CODL</a>, having
			inserted the current block number.
		</td>
	</tr>
</table>

<p class="indent">
	<u>ERROR</u>
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">FAIL 27;</td>
		<td class="noborder">declaration without identifier.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page61.jpg">[PAGE -58-]</a>
</p>

<p id="ENDSTA" class="center">
	<u>ENDSTA</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/ENDSTA.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ENDSTA">[Code]</a>
</p>

<p class="indent">
	This subroutine is used to complete the processing
	of a statement. If an input/output statement is
	terminating the marker is cleared and <a href="#E">E</a> set to 1.
	<a href="#DECSTA">DECSTA</a> is set to statement level and
	<a href="#EXP">EXP</a> is used to
	change the state variable <a href="#E">E</a> to expression level if
	necessary. If <a href="#E">E</a> is zero, <a href="#TAKE">TAKE</a> is called to generate
	the correct instruction, and <a href="#ARITH">ARITH</a>,
	<a href="#E">E</a>, and E<a href="#EXPTYP">EXPTYP</a> are
	set up to deal with the next statement.
</p>

<p class="indent">
	Otherwise, if the current section contains an
	identifier (which must be a procedure identifier), the
	<a href="#NAMELIST">Name List</a> is scarched to discover whether this
	identifier is a formal parameter before generating the relevant
	instruction. <a href="#EXPTYP">EXPTYP</a> is cleared before exit.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder" style="width:10ch">FAIL 32 &nbsp;;</td>
		<td class="noborder">
			constant or identifier other than
			procedure zero used as statement.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 20 &nbsp;;</td>
		<td class="noborder">
			Array element or switch used as statement.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page62.jpg">[PAGE -59-]</a>
</p>

<p id="FORCOM" class="center">
	<u>FORCOM</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/FORCOM.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FORCOM">[Code]</a>
</p>

<p class="indent">
	This subroutine is called at the end of a for list
	element to compile the correct object program operation.
	<a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a> are used to
	 complete 	the processing of
	the preceding expression and the top of the stack (<a href="#TS">TS</a>)
	is then used to determine between the various kinds of
	list element.
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder">EXAMPLE</td>
		<td class="noborder">(i)</td>
		<td class="noborder">
			<u>for</u> C V := a,
			.........&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simple
		</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			<u>for</u> C V := 1 <u>step</u> 1 <u>until</u> n ... UNTIL
		</td>
	</tr>
	<tr>
		<td class="noborder"></td>
		<td class="noborder">(iii)</td>
		<td class="noborder"><u>for</u> C V := a <u>while</u> a <10, ..... while
	</tr>
</table>

<p>N.B. if <a href="#FORCOM">FORCOM</a> is called by ',' this could be the delimiter
	between dimensions in an array subscript used in a list
	element.
</p>

<table class="noborder margin0t">
	<tr>
		<td class="noborder">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td class="noborder">(iv)&nbsp;</td>
		<td class="noborder"><u>for</u> C V := A [1,3], .....[</td>
	</tr>
</table>

<p class="indent">
	In cases (i), (ii) and (iii) the type of the controlled
	variable is restored from the stack into
	<a href="#LOKTYP">LOKTYP</a>, and <a href="#TYPCHK">TYPCHK</a>
	is used to compile a type conversion if necessary. The
	relevant object program operation is then compiled and a
	check is made that the top of the stack is for, and an
	exit is made back to ',' or do.
</p>

<p class="indent">
	In case (iv), the number of dimensions is updated and
	stacked with '[' and a return made to the
	<a href="#CENTRAL">CENTRAL LOOP</a>, to
	read the next ALGOL section.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin2t">
	<tr>
		<td class="noborder">FAIL 96;</td>
		<td class="noborder">incorrectly constructed for clause.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 43;</td>
		<td class="noborder">missing ] on array element preceding <u>do</u>.
	</tr>
</table>

<p>
	<a href="Description Pages/page63.jpg">[PAGE -60-]</a>
</p>

<p id="FCLAPS" class="center">
	<u>COLLAPSE&nbsp;FORMAL&nbsp;PARAMETERS</u> (FCLAPS)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/FCLAPS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FCLAPS">[Code]</a>
</p>

<p class="indent">
	This subroutine is called from the delimiter ; ,
	such as in the following example:
</p>

<pre class="margin1 courier">
<u>integer</u> <u>procedure</u> P (a,b,c); <u>integer</u> a,b,c ;
        P := a + b ;
</pre>

<p class="indent">
	At this stage the name list will look like this
</p>

<img src="images/translator_fig11.jpg" alt="DIAGRAM" class="margin1">

<p class="indent">
	The block stopper is erased, and for type procedures a
	check made that an assignment has been made to the
	procedure identifier during the procedure body.
</p>

<p>
	The <a href="#V">V</a> bit in the procedure name list entry is cleared,
	as we are now no longer in the procedure body and recursion
	cannot occur. <a href="#WM">WM</a> is set and a warning message is given
	for every paraneter not used, as these parameters are
	inspected and condensed to one-word entries containing
	type and whether by value or not.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 16 &nbsp;</td>
		<td class="noborder">No assignment to type procedure identifier.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page64.jpg">[PAGE -61-]</a>
</p>

<p id="NCLAPS" class="center">
	<u>COLLAPSE&nbsp;NAME&nbsp;LIST</u> (NCLAPS)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/NCLAPS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_NCLAPS">[Code]</a>
</p>

<p class="indent">
	This subroutine, called from <a href="#END"><u>end</u></a>, resets the
	<a href="#NLP">Name List Pointer</a> to the position it held before the
	current block began, and reinstates the previous block number.	If any
	identifier is declared and not used, a warning	message is produced, except
	 in the cases of switch names which are ignored, and label names where the
	 warning message is upgraded to a fail.
	The variable <a href="#CNL">CNL</a> is set on entry so that if more than one label
	is unallocated 	each will give a failure message.
</p>

<p class="indent">
	<u>ERROR</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 79 &nbsp;;</td>
		<td class="noborder">unallocated label.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page65.jpg">[PAGE -62-]</a>
</p>

<p id="REAL_INTEGER_BOOL" class="center">
	<u>real</u>, <u>integer</u>, <u>Boolean</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/REAL_INTEGER_BOOL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_REAL">[Code]</a>
</p>

<p class="indent">
	<a href="#W">W</a> is set up with the corresponding type, and a
	check is made that <a href="#DECTYP">DECTYP</a> is zero. If not, this
	would mean that we were already in a declaration (as 	<a href="#DECTYP">DECTYP</a> is set to
	zero on ;) such as
</p>

<p class="margin2">
	<u>begin</u> <u>real</u> <u>integer</u> ......
</p>

<p class="indent">
	<a href="#DECTYP">DECTYP</a> is then set up with the type from <a href="#W">W</a>, and
	<a href="#DEC">DEC</a> is called with a parameter of 1. This in effect
	looks back over its shoulder to see whether this is
	the first declaration in a block (if it is <a href="#DEC">DEC</a> will
	have to update Current Block Number, <a href="#DECSTA">DECSTA</a>
	etc).
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 47;</td>
		<td class="noborder">illegal declaration</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 76;</td>
		<td class="noborder">misplaced delimiter</td>
	</tr>
</table>

<br><br><br>

<p id="ARRAY" class="center">
	<u>array</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/ARRAY_ARENT2.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ARRAY">[Code]</a>
</p>

<p class="indent">
	The subroutine <a href="#DEC">DEC</a> is used as described above, and
	a check is made on <a href="#DECTYP">DECTYP</a>. The failure path is exactly
	like the one above, where we are already in a declaration
	other than real, integer or Boolean (e.g. "<u>begin</u> <u>string</u>
	<u>array</u>....").
</p>

<p class="indent">
	If <a href="#DECTYP">DECTYP</a> is set to real, integer, or Boolean, it
	is further limited to array; if <a href="#DECTYP">DECTYP</a> is 0, ALGOL specifies
	that a non-type array is treated as a real array, and <a href="#DECTYP">DECTYP</a>
	is thus set. <a href="#MAMPS">MAMPS</a> (Make Array Maps) is then stacked.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(i)</td>
		<td class="noborder">
			so that inspection of the top of the stack
			can show us that we are in an array
			declaration (this is particularly important
			when the array bound variables are them
			selves nasty things like procedure calls),
			and
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			so that the relevant object program can be
			generated at the end of the array bound
			list (see <a href="file:Flowcharts/RSBRAK.pdf"">] flowchart</a>)
		</td>
	</tr>
</table>

<p class="indent">
	<a href="#ARRCOU">ARRCOU</a> becomes zero ready to count array names (see
	<a href="#COMMA">, (comma)</a> which calls <a href="#DECL">DECL</a> (3))
</p>

<p class="margin2">
	e.g.: <u>begin</u> <u>real</u> <u>array</u> A,B,C,D, [ ......
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 72 ;</td>
		<td class="noborder">illegal declaration</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page66.jpg">[PAGE -63-]</a>
</p>

<p id="BEGIN" class="center">
	<u>begin</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/BEGIN.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_BEGIN">[Code]</a>
</p>

<p class="indent">
	This routine checks that <u>begin</u> has been used to
	start a block or statement and sets <a href="#DECSTA">DECSTA</a> to zero.
	Note that no block entry is compiled or set up in the
	<a href="#NAMELIST">Namelist</a> since it is not yet known if this begin starts
	a compound statement or a block. This work is done in
	<a href="#DEC">DEC</a> by the first declaration following a begin.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder">
	<tr>
		<td class="noborder">FAIL 60;</td>
		<td class="noborder">
			illegal use of <u>begin</u> i.e. in expression or
			following :=
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page67.jpg">[PAGE -64-]</a>
</p>

<p id="DO" class="center">
	<u>do</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/DO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_DO">[Code]</a>
</p>

<p class="indent">
	The subroutine <a href="#FORCOM">FORCOM</a> completes the object program
	instructions for the preceding for list element. The
	object program 'For Statement End' is then compiled and
	an instruction to update the address following 'For' in
	the object program to point to the controlled loop. A
	stack entry is made of <u>for</u> <u>begin</u> to show that this is a
	for statement, with the second address following 'For'
	which will be updated to point to the statement following
	the for statement. The <a href="#BN">block name</a> is also updated to
	its highest value.
</p>

<p class="indent">
	The 'for clause' is defined in ALGOL as being
	followed by a Statement (a construct wide enough to include
	a Block, or another for statement). <a href="#E">E</a> is therefore set
	to 1 (to show that a statement is expected); <a href="#ARITH">ARITH</a> and
	<a href="#F">F</a> (the for clause marker) are cleared - the latter was
	only of use during the processing of the for clause.
</p>

<p>
	<a href="Description Pages/page68.jpg">[PAGE -65-]</a>
</p>

<p id="ELSE" class="center">
	<u>else</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/ELSE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ELSE">[Code]</a>
</p>

<p class="indent">
	The object program for the preceding statement or
	expression is completed by <a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a>.
	If the top of the stack is 'then S' the subroutine <a href="#ENDSTA">ENDSTA</a> is
	used to compile the procedure zero call.
</p>

<p class="indent">
	e.g. <u>if</u> a < b <u>then</u> procedure <u>else</u> <u>go</u> <u>to</u> label;
</p>

<p class="indent">
	The top of the stack is then tested for ‘then S' or 'then E'
	to differentiate between a conditional statement and a
	conditional expression. In each case a UJ operation is
	compiled which will be updated at the end of the statement,
	and the <a href="#IFJ">IFJ</a> operation around the <u>then</u> part is updated.
</p>

<p class="indent">
	Finally 'else E' or 'else S' is stacked, (in the case
	of an expression <a href="#TYPBOX">TYPBOX</a> is stacked to show the type of the
	<u>then</u> expression), as is the address of the incomplete UJ
	operation around the <u>else</u> part.
</p>

<p class="indent">
	In the case of conditional statements <a href="#E">E</a>, <a href="#ARITH">ARITH</a>
	and <a href="#EXPTYP">EXPTYP</a> are reset for the following statement.
</p>

<p>
	<a href="Description Pages/page69.jpg">[PAGE -66-]</a>
</p>

<p id="END" class="center">
	<u>end</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/END.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_END">[Code]</a>
</p>

<p class="indent">
	<a href="#DECTYP">DECTYP</a> is checked to make sure that this delimiter
	does not complete a declaration (e.g. <u>begin</u> <u>real</u> a <u>end</u>),
	and the subroutines <a href="#ENDSTA">ENDSTA</a> and <a href="#UNSTAK">UNSTAK</a>
	are used to complete the processing of the preceding statement, The top of
	the stack is then inspected; if <u>end</u> shows that we are
	ending a for statement (TS = <u>for</u> <u>begin</u>) we must cycle
	round (having compiled something into the object program
	using FSEND) and inspect it again, because ALGOL's definition
	of a for statement is recursive (see diagram) and therefore
	one <u>end</u> may terminate lots of for statements.
</p>

<img src="images/translator_fig12.jpg" alt="DIAGRAM" class="left">

<p class="indent">
	Having unstacked any lurking <u>for</u> <U>begins</u>, the top
	of the stack should now be a form of <U>begin</U>. If it is
	not it is a failure. e.g. <u>for</u> <u>end</u>.
</p>

<p class="indent">
	Where the top of the stack is <u>begin</u>, this is the end
	of a compound statement. <u>begin</u> <u>TR</u> signifies that this
	is the end of a block containing no array (i.e. no block
	entry compiled), and <u>begin</u> <u>ALL</u> that this is the end of a
	block containing an array (and therefore there is an
	unconditional jump to be updated). For the relevant
	entries that are unstacked here, see <a href="#DEC">DEC</a>.
</p>

<p class="indent">
	In the case of a block, the <a href="#NAMELIST">name list</a> is collapsed
	back to the first entry for this block, as all the
	variables declared local to this block are now no longer
	valid.
</p>

<p class="indent">
	A test is then made for the end of the program (is
	stack empty) and if so <a href="#ENDPRO">ENDPRO</a> is accessed. Otherwise
	<a href="#BCR">BCR</a> is called to extract any comment following <u>end</u>
</p>
<p class="margin2">
	e.g. <u>end</u> of this routine;
</p>

<p class="indent">
	A warning message is emitted if there is a delimiter in
	this section, which will catch
</p>

<p class="margin3">
	<u>end</u>
	<br>
	x := 1;
</p>

<p>
	Final exit is to <a href="#OUT2">OUT2</a>, as <a href="#BCR">BCR</a> will already have recognised
</p>

<p>
	<a href="Description Pages/page70.jpg">[PAGE -67-]</a>
</p>

<p>
	one of the delimiters which terminate an end comment,
	namely <u>end</u>, <u>else</u> or ;.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 40 ;</td>
		<td class="noborder">Top of stack not a begin</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page71.jpg">[PAGE -68-]</a>
</p>

<p id="FOR" class="center">
	<u>for</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/FOR.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FOR">[Code]</a>
</p>

<p class="indent">
	After checking that <u>for</u> is used at the start of
	a statement (using <a href="#M">M</a>, <a href="#F">F</a> and
	<a href="#EXP">EXP</a>) <a href="#DECSTA">DECSTA</a> is set to
	/0&nbsp;&nbsp;0 since this is a statement. A stack entry is made of
	<u>for</u> together with its address in the object program.
	This address will be used by do to update the pointer
	to controlled statement. The current <a href="#BN">block name</a> is
	stacked before being updated to the next highest block
	name for the for block.
</p>

<p class="indent">
	The object program compiled contains two markers
	which will be updated by the addresses to the controlled
	statement and the statement following this for statement.
</p>

<p class="indent">
	The subroutine <a href="#BCR">BCR</a> is used to read the next ALGOL
	section which should be 'controlled variable := '
</p>

<p class="indent">
	e.g. <u>for</u> cv := 1 <u>step</u> 1 <u>until</u> n <u>do</u> _________ ;
</p>

<p class="indent">
	<a href="#TAKE">TAKE</a> compiles the correct object instruction for
	the controlled variable and a stack entry is made for the
	first list element with the type, held in <a href="#TYPBOX">TYPBOX</a>, of
	the 	controlled variable. If the controlled variable is type
	<u>real</u>, the list elements must all be <u>real</u> and similarly when
	the controlled variable is type <u>integer</u>. The stack entry
	'simple' is used to distinguish a simple list element
	from a 'step' or 'while' element.
</p>

<p class="indent">
	Finally, <a href="#ARITH">ARITH</a> and <a href="#E">E</a> are set for the
	following list element expression and <a href="#F">F</a> is set to 1 to show that this is
	a for clause.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 21 &nbsp;;</td>
		<td class="noborder">
			controlled variable is not a simple
			variable.
		</td>
		</tr>
		<tr>
			<td class="noborder">PAIL 44 &nbsp;;</td>
			<td class="noborder">
				<u>for</u> doesn't start a statement
			</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page72.jpg">[PAGE -69-]</a>
</p>

<p id="GOTO" class="center">
	<u>go</u> <u>to</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/GOTO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_GOTO">[Code]</a>
</p>

<p class="indent">
	After checking that the delimiter is used to start
	a statement, <a href="#DECSTA">DECSTA</a> is set to /0&nbsp;&nbsp;0 to show
	this is a 	statement, The delimiter is stacked as GT since it
	is not yet known if this is a <u>go</u> <u>to</u> label or
	<u>go</u>&nbsp;<u>to</u> switch statement.
</p>

<p class="margin2">
	e.g. <u>go</u> <u>to</u> labelname;
<br><br>
	<u>go</u> <u>to</u> s [a+b] ;
</p>

<p class="indent">
	<a href="#E">E</a> and <a href="#EXPTYP">EXPTYP</a> are set up for the
	following label or switch expression.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 42 &nbsp;;</td>
		<td class="noborder">
			<u>go</u> <u>to</u> follows an identifier or
			constant.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page73.jpg">[PAGE -70-]</a>
</p>

<p id="IF" class="center">
	<u>if</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/IF.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_IF">[Code]</a>
</p>

<p class="indent">
	The initial test removes as a failure such phrases
	as:
</p>

<p class="margin2">
	b := (a+b)  <u>if</u> ...
	<br>
	b := A[b] <u>if</u> ...
	<br>
	<u>if</u> a &gt; <u>then</u> <u>if</u> ...
	<br>
	b := a+b <u>if</u> ...
</p>

<p class="indent">
	<a href="#EXP">EXP</a> is then called to set <a href="#E">E</a> to zero if
	the preceding delimiter was := as in
</p>

<p class="margin2">
	a := <u>if</u> ...
</p>

<p class="indent">
	In the case of <a href="#E">E</a> being equal to 1, <a href="#DECTYP">DECTYP</a> is tested.
	It is normally zero (i.e. we are not in a declaration)
	and <a href="#DECSTA">DECSTA</a> is set to /0&nbsp;&nbsp;0. It may
	however be set to <u>array</u>, as in:
</p>

<p class="margin2">
	<u>real</u> <u>array</u> A [1 : PROC (<u>if</u> ...
</p>

<p class="indent">
	In this case of course <a href="#DECSTA">DECSTA</a> must not be changed.
	A test is then made to see if this is an actual parameter,
	and if it is <a href="#E">E</a> is set to zero.
</p>

<p class="indent">
	If <a href="#E">E</a> was not equal to 1, a further test is made to
	remove constructs such as
</p>

<p class="margin2">
	y + <u>if</u>
</p>

<p class="indent">
	The stack entry saves the state variables <a href="#ARITH">ARITH</a>, <a href="#E">E</a>
	and <a href="#EXPTYP">EXPTYP</a> and stacks if to be checked by the
	following <u>then</u>, <a href="#ARITH">ARITH</a> and <a href="#E">E</a> are then set up for the Boolean
	expression in the <u>if</u> clause.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t"">
	<tr>
		<td class="noborder">FAIL 67;</td>
		<td class="noborder"><u>if</u> misused</td>
	</tr>
	<tr>
		<td CLASS="noborder">FAIL 100;</td>
		<td class="noborder">
			<u>if</u> must not be used after log., arith. or
			rel. operator.
		</td>
	</tr>
		<tr>
			<td class="noborder">FAIL 68;</td>
			<td class="noborder">
				<u>if</u> used in declaration other than array declaration.
			</td>
		</tr>
</table>


<p>
	<a href="Description Pages/page74.jpg">[PAGE -71-]</a>
</p>

<p id="PROCED" class="center">
	<u>Procedure</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/PROCED.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PROCED">[Code]</a>
</p>

<p class="indent">
	The subroutine <a href="#DEC">DEC</a> is used to set up a block if
	this is the first declaration in the block, a stopper
	is put in the <a href="#NAMELIST">name list</a>, the marker
	<a href="#PH">PH</a> is set to show
	that a procedure heading is being processed, and a call
	is made to <a href="#BCR">BCR</a> to read the next ALGOL section i.e.
	'procedure name' (. A check is made that the preceding
	delimiter was <u>real</u> <u>integer</u>, <u>Boolean</u> or non-type. Unless
	the procedure is own code an unconditional jump is compiled
	to jump round the procedure body and a stack entry is made
	of <u>proc.</u> <u>begin</u> together with various state variables and
	the address (<a href="#PP">PP</a>) of the incomplete UJ operation to be
	updated at the end of the procedure body.
</p>

<p class="indent">
	<a href="#DECSTA">DECSTA</a> is set to statement level for the procedure
	statement following the specification part, the number of
	parameters (<a href="#PRMCOU">PRMCOU</a>) is set to zero and the current
	block name (<a href="#BN">BN</a>) is updated for the procedure block.
</p>

<p class="indent">
	Tf the procedure has no parameters (delimiter is ;)
	<a href="#DECTYP">DECTYP</a> is set to procedure zero and the procedure
	name is declared in the namelist using the subroutine
	<a href="#DECL">DECL</a>. The
	procedure entry operation is compiled, <a href="#DECTYP">DECTYP</a> cleared and
	a call is then made to <a href="#BCR">BCR</a> to check whether the procedure
	body is ALGOL or own code.
</p>

<p class="indent">
	If the procedure has parameters, <a href="#DECTYP">DECTYP</a> is set and
	the procedure name is declared in the namelist. <a href="#PRCENT">PRCENT</a>
	is used to hold the namelist address of the procedure name,
	and <a href="#PROC">PROC</a> is set to 1. The loop that follows reads a
	formal parameter, checks that it has not already been
	declared, enters it in the namelist and updates the count
	of parameters. When ')' has been read, the procedure entry
	operation can be compiled and the namelist entry completed
	with the number of formal parameters; <a href="#PROC">PROC</a> and <a href="#DECTYP">DECTYP</a> are
	cleared.
</p>

<p class="indent">
	The next call to <a href="#BCR">BCR</a> should fetch ; which terminates
	the formal parameter part.
</p>

<img src="images/translator_fig13.jpg" alt="DIAGRAM" class="left">

<p class="indent">
	Another call is made to <a href="#BCR">BCR</a> to determine whether a
	value part or the specification part follows. Each
	identifier in the value part is checked for appearance
	in the formal parameter list. v:=l in the namelist entry.
	When the terminating ';' is read the next ALGOL section
	is read (specifier,) and the specification part is processed.
</p>

<p class="indent">
	This consists of specifiers followed by identifier
	list(s) e.g. <u>real</u> a,c; There is-an inner loop to read
	each identifier in the list following the specifier, check
	that it is a formal parameter and complete the namelist
	entry. If the formal parameter is a switch the number of
	dimensions is set to 1 but if it is an array or procedure
</p>

<p>
	<a href="Description Pages/page75.jpg">[PAGE -72-]</a>
</p>


<p class="center">
	<u>Procedure</u> (Continued)
</p>

<p>
	the number of dimensions or parameters is not yet known
	and is set to + 15, This number will be updated at
	the first occurence of this identifier with its parameters,
	and subsequent occurences must agree,.
</p>

<p clas="indent">
	If the delimiter is ';' this could be the end of the
	specification part or the end of this specifier list.
	In the former case, a check is now made that each formal
	parameter has been specified and if called by value that
	the type is not switch, string or procedure. The program
	then compiles the check words for the run time parameter
	checking.
</p>

<p class="indent">
	Finally, a check is made to determine whether the
	program body is ALGOL or own code, If the latter <a href="#DECSTA">DECSTA</a>
	is reset to declaration level, the formal parameters are
	collapsed and the next delimiter is read to discard the ;
	903 ALGOL requires the parameters of formal procedures to
	be called by name, this is checked in <a href="#PRAMCH">PRAMCH</a> however,
    when a parameter is found to be of type procedure.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 101 ;</td>
		<td class="noborder">procedure name not followed by ; or (</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 102 ;</td>
		<td class="noborder">formal parameter part not followed by ;</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;90 ;</td>
		<td class="noborder">wrong delimiter in value or specifier part</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 109 ;</td>
		<td class="noborder">constant not allowed in procedure heading</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;65 ;</td>
		<td class="noborder">illegal specifier</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;17 ;</td>
		<td class="noborder">
			identifier in specification part is not a formal parameter, or
			formal parameter not fully specified
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;94 ;</td>
			<td class="noborder">
				string, switch or procedure called by value
			</td>
	</tr>
	<tr>
		<td class="noborder" style="width:11ch">FAIL &nbsp;&nbsp;6 ;</td>
		<td class="noborder">more than 14 parameters</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;86 ;</td>
		<td class="noborder">procedure inside another declaration</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;85 ;</td>
		<td class="noborder">Name list overflows</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;92 ;</td>
		<td class="noborder">Identifier not specified</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;88 ;</td>
		<td class="noborder">formal parameter not followed by ) or ,</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page76.jpg">[PAGE -73-]</a>
</p>

<p id="STEP_UNTIL_WHILE" class="center">
	<u>step</u>, <u>until</u>, <u>while</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/STEP_UNTIL_WHILE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_STEP">[Code]</a>
</p>

<p class="indent">
	The first test is to ensure that these delimiters
	are only used in a for clause, The arithmetic expression
	preceding the current delimiter is then completed by the
	subroutines <a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a>, when
	 the top of the stack
	should then be simple, The variable <a href="#G">G</a> is set up with the
	quantity stacked with simple, and <a href="#LOKTYP">LOKTYP</a> is also set
	up. <a href="#TYPCHK">TYPCHK</a> is called to generate any conversion necessary, e.g.:-
	</p>

<p class="margin1">
	<u>real</u> A, B ; <u>integer</u> c;
	for A := B+c <u>step</u>
</p>

<p>
	and <a href="#TYPBOX">TYPBOX</a> is then set to <a href="#LOKTYP">LOKTYP</a>. The current
	delimiter is then examined.
</p>

<p class="indent">
	In the case of the delimiter <u>step</u>, simple is restacked
	with a marker to indicate that the delimiter <a href="#UNTIL">UNTIL</a> is
	required, and an instruction compiled (an example of a compiled
	for statenent is given below). In the case of the delimiter
	<u>while</u> <a href="#ARITH">ARITH</a> is set up for the algebraic
	expression following.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL 78 ;</td>
		<td class="noborder">corresponding <u>for</u> missing</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 21 ;</td>
		<td class="noborder">":=" omitted from <u>for</u> clause</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 80 ;</td>
		<td class="noborder">
			<u>step</u>, <u>until</u> or <u>while</u> misused in
			for list element.
		</td>
	</td>
</table>

<img src="images/translator_fig14.jpg" alt="DIAGRAM" class="margin1">

<p>
	<a href="Description Pages/page77.jpg">[PAGE -74-]</a>
</p>

<p id="SWITCH" class="center">
	<u>switch</u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/SWITCH.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_SWITCH">[Code]</a>
</p>

<p class="indent">
	A check is made that we are not already in a
	declaration and then <a href="#DECTYP">DECTYP</a> is set to switch. The
	subroutine <a href="#DEC">DEC</a> is used to set up a block if this is the
	first declaration in the block. The next ALGOL section
	is fetched, which should be 'switchname :=', and
	<a href="#LABCOU">LABCOU</a> is cleared. <a href="#DECL">DECL</a> is used to declare the switchname in the
	<a href="#NAMELIST">namelist</a> and make an entry in the
	<a href="#CODL">label data area
	(CODL)</a>.
</p>

<p class="insert">
	The loop is used to process each label in the switch
	list. (IFIP ALGOL allows only labels in the switch list).
</p>

<p class="indent">
	e.g. <u>switch</u> S := TOM, DICK, HARRY;
</p>

<p class="indent">
	Each label is declared in the namelist together
	with the address of the label in <a href="#CODL">CODL</a> and <a href="#BN">BN</a> is entered
	in label entry in <a href="#CODL">CODL</a>. At the end of the switch list
	when ';' is read, the number of labels is entered in <a href="#CODL">CODL</a>
	and <a href="#DECTYP">DECTYP</a> is cleared.
</p>

<p class="indent">
	e.g. layout of <a href="#CODL">CODL</a> for the above switch declaration.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder center"><u>CODL</u><br><br></td>
		<td class="noborder">&nbsp;<br><br></td>
		<td class="noborder">&nbsp;<br><br></td>
		<td class="noborder" colspan=2><u>Namelist</u><br><br></td>
	</tr>
	<tr>
		<td class="noborder center">n<br>n + 1</td>
		<td class="noborder right">+3<br>+0</td>
		<td class="noborder">... no. of labels</td>
		<td class="noborder center">s</td>
		<td class="noborder center">n</td>
	</tr>
	<tr>
		<td class="noborder center">n + 2<br>n + 3</td>
		<td class="noborder right">BN<br>+0</td>
		<td class="noborder">... for TOM</td>
		<td class="noborder center">TOM</td>
		<td class="noborder center">n + 1</td>
	</tr>
	<tr>
		<td class="noborder center">n + 4<br>n + 5</td>
		<td class="noborder right">BN<br>+0</td>
		<td class="noborder">... for DICK</td>
		<td class="noborder center">DICK</td>
		<td class="noborder center">n + 3</td>
	</tr>
	<tr>
		<td class="noborder center">n + 6<br>n + 7</td>
		<td class="noborder right">BN<br>+0</td>
		<td class="noborder">... for HARRY</td>
		<td class="noborder center">HARRY</td>
		<td class="noborder center">n + 5</td>
	</tr>
</table>

<p class="indent">
	When the left-hand label is declared, its object program address is
	placed in the <a href="#CODL">CODL</a> label entry overwriting the +0.
</p>

<p class="indent">
	<u>ERRORS</us>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;26;</td>
		<td class="noborder">
			no := following switch identifier in
			switch declaration, or switch
			misplaced.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;4;</td>
		<td class="noborder">wrong identifier in switch list.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page78.jpg">[PAGE -75-]</a>
</p>

<p id="THEN" class="center">
	<u>then</u></u>&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/THEN.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_THEN">[Code]</a>
</p>

<p class="indent">
	This routine first tests that we are at expression
	level (if not, it fails) and then completes the processing
	of the algebraic expression following if by calling <a href="#TAKE">TAKE</a>
	and <a href="#UNSTAK">UNSTAK</a>. If is then unstacked and
	<a href="#ARITH">ARITH</a>, <a href="#E">E</a> and <a href="#EXPTYP">
	EXPTYP</a> are restored. The state variable <a href="#E">E</a> is then used to decide
	whether <u>then</u> should be stacked as "<u>then</u> S" or ""<u>then</u>
	E", The pord pointer (<a href="#PP">PP</a>) is also stacked, ready to
	update the <a href="#IFJ">IFJ</a> when the delimiter <u>else</u> is met.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;&nbsp;97;</td>
		<td class="noborder"><u>then</u> in statement</td>
	</tr>
	<tr>
		<td class="noborder">FAIL&nbsp;&nbsp;69;</td>
		<td class="noborder">
			corresponding if has been omitted
			or conditional expression without
			an <u>else</u>.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page79.jpg">[PAGE -76-]</a>
</p>

<p id="BECOMS" class="center">
	:=&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/BECOMS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_BECOMS">[Code]</a>
</p>

<p class="indent">
	There are three possible uses of the delimiter
	:= as follows:
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">(i)</TS">
		<td class="noborder">
			in a switch declaration, e.g.
			<br>&nbsp;&nbsp;&nbsp;&nbsp;
			<u>switch</u> S := ......
		</td>
	</tr>
	<tr>
		<td class="noborder">(ii)</td>
		<td class="noborder">
			in a for clause, e.g.
			<br>&nbsp;&nbsp;&nbsp;&nbsp;
			<u>for</u> v := 1 <u>step</u> ......
		</td>
	</tr>
	<tr>
		<td class="noborder">(iii)</td>
		<td class="noborder">in an assignment statement.</td>
	</tr>
</table>

<p class="indent">
	The first two are dealt with under <u>switch</u> and <u>for</u>
	respectively, and this routine merely deals with assignment statements.
	After checking that we are not assigning to a constant or an expression and
	 that we are not in	a declaration, for clause or procedure call,
	 <a href="#DECSTA">DECSTA</a> and
	<a href="#SV">SV</a> set to /0&nbsp;&nbsp;0 and
	<a href="#TAKE">TAKE</a> deals with the variable (simple
	or subscripted) which precedes the delimiter.
</p>

<p class="indent">
	As we require all left hand elements in an assignment to be the same type
	the top of the stack is then
	inspected to see if it is a :=. If not <a href="#LHTYP">LHTYP</a> is set
	to <a href="#TYPBOX">TYPBOX</a> and the delimiter is stacked, otherwise
	<a href="#LHTYP">LHTYP</a> and <a href="#TYPBOX">TYPBOX</a> are tested for equality and the multiple store
	function (STA) is stacked.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder">
	<tr>
		<td class="noborder">FAIL&nbsp;&nbsp;28&nbsp;;</td>
		<td class="noborder">
			:= preceded by constant or used inside
			expression.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;52 ;</td>
		<td class="noborder">
			:= must not appear in actual parameter
			list, or in a type or array declaration.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;&nbsp;7 ;</td>
		<td class="noborder">
			 := appears in a for statement and other
			than in assignment to controlled variable.
		</td>
	</tr>
	<tr>
		<td class="noborder">
			<a href="#FAIL">FAIL</a> &nbsp;112;</td>
		<td class="noborder">
			Different types on Left hand side of an
			assignment.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page80.jpg">[PAGE -77-]</a>
</p>

<p id="SEMICO" class="center">
	;&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/SEMICO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_SEMICO">[Code]</a>
</p>

<p class="indent">
	Most of the processing for a ; in a declaration
	is dealt with in that declaration
</p>

<p class="indent">
	e.g. switch or scalar do their own, and array
	declaration is done in <a href="#RSBRAK">RSBRAK</a>
</p>

<p class="indent">
	<a href="#STATRM">STATRM</a> is then called to complete the processing
	of the <u>read</u> or <u>print</u> statement.
	<a href="#ENDSTA">ENDSTA</a> is used to
	complete the processing of the constituents of the
	statement otherwise, and the top of the stack is then
	tested.
</p>

<p class="indent">
	If this is <u>for</u> <u>begin</u>, the one or more for statenents
	are completed. If it is <u>proc</u> <u>begin</u> this is unstacked,
	the variables stacked with it are restored, and
	<a href="#FCLAPS">COLLAPSE&#32;FORMAL&#32;PARAMETERS</a> is called to condense the formal parameter entries
	in the <a href="#NAMELIST">Name List</a> to two parts - type, and
	whether the parameter is called by name or value.
</p>

<p class="indent">
	If the top of the stack is any other form of <u>begin</u>,
	the routine is finished.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;53&nbsp;&nbsp;;</td>
		<td class="noborder">TS not a form of begin.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 93 &nbsp;;</td>
		<td class="noborder">Declaration ends incorrectly (STATRM)</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 20 &nbsp;;</td>
		<td class="noborder">Array or Switch element as statement (ENDSTA)</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 32 &nbsp;;</td>
		<td class="noborder">
			Constant or other than a non-type
			procedure zero as a statement (ENDSTA)
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page81.jpg">[PAGE -78-]</a>
</p>

<p id="AOP" class="center">
	Arithmetic Operators (+ - x / <u>div</u> )&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/AOP.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_AOP">[Code]</a>
</p>

<p class="indent">
	As the treatment of these operators differs only
	slightly their stacking priority is recorded and then
	they share the routine. Their validity is checked
	using <a href="#EXP">EXP</a> which sets <a href="#E">E</a> to expression
	level. If the
	operator is not preceded by an identifier or constant
	and is not a closing bracket it is stacked with its type
	and associated priority, except for special cases unary
	plus which is ignored, and unary minus which is noted
	for special action.
</p>

<p class="indent">
	Otherwise the identifier or constant is dealt with
	and <a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a> are called, or
	in the case of the closing bracket just <a href="#UNSTAK">UNSTAK</a>.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1">
	<tr>
		<td class="noborder">FAIL&nbsp;30&nbsp;&nbsp;;</td>
		<td class="noborder">Adjacent arithmetic operators,.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 57 &nbsp;;</td>
		<td class="noborder">Adjacent operators inadmissable.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page82.jpg">[PAGE -79-]</a>
</p>

<p id="RLT" class="center">
	Relational Operators (&lt; &gt; &le; &ge; &ne; =)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/RLT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_RLT">[Code]</a>
</p>

<p class="indent">
	After checking the validity of the use of the
	operator, <a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a> are used
	to process the preceding identifier or constant, and to unstack any
	operators with priorities greater than or equal to the priority of the
	current delimiter.
</p>

<p class="indent">
	The current operator is then stacked with its
	stack priority and the type of the preceding variable
	or expression. <a href="#E">E</a> is set to expression level.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;58&nbsp;&nbsp;;</td>
		<td class="noborder">illegal use of relational operator.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page83.jpg">[PAGE -80-]</a>
</p>

<p id="LOGOP" class="center">
	Logical Operators (&sup; &or; &and; &not; &equiv;)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/LOGOP.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_LOGOP">[Code]</a>
</p>

<p class="indent">
	The stack priority of the present operator is stored
	and a check is made on the use of this delimiter.
	setting <a href="#E">E</a> to expression level, further checks are
	if the current operator is a &not;. Except in that
	<a href="#TAKE">TAKE</a> and <a href="#UNSTAK">UNSTAK</a>
	are used to process the preceding
	fier and to unstack any operators with priorities
	or equal to the priority of the current operator,
	the delimiter is stacked with its priority.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;58&nbsp;&nbsp;;</td>
		<td class="noborder">Logical operator misplaced
	</tr>
	<tr>
		<td class="noborder">FAIL 59 &nbsp;;</td>
		<td class="noborder">illegal use of &not;</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page84.jpg">[PAGE -81-]</a>
</p>

<p id="LSBRAK" class="center">
	[&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/LSBRAK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_LSBRAK">[Code]</a>
</p>

<p class="indent">
	This routine deals with the use of this delimiter
	for a subscripted variable, a switch designator or as
	the start of a bound pair list in an array declaration.
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">Examples</td>
		<td class="noborder">
			(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...... + TABLE [2,6]
		</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">
			(ii)&nbsp;&nbsp;&nbsp;&nbsp; <u>go</u> <u>to</u> SWITCHLIST [4]
		</td>
	</tr>
	<tr>
		<td class="noborder">&nbsp;</td>
		<td class="noborder">
			(iii)&nbsp;&nbsp;&nbsp; <u>array</u> TABLE [1:p, -3:n]
		</td>
	</tr>
</table>

<p class="indent">
	If <a href="#DECTYP">DECTYP</a> is clear, this can be a subscripted
	variable or a switch designator, and <a href="#DECSTA">DECSTA</a> is set to
	statement level, <a href="#TAKE">TAKE</a> is used to process the switch
	or array identifier and leaves <a href="#I">I</a> pointing to the
	<a href="#NAMELIST">namelist</a>
	entry. If the preceding identifier is type <u>array</u>, a
	stack entry is made of [ together with the current values
	of the state variables. <a href="#E">E</a>, <a href="#ARITH">ARITH</a>
	and <a href="#EXPTYP">EXPTYP</a> are then
	set for the following arithmetic expression.</p>

<p class="indent">
	If the preceding identifier is type <u>switch</u> a test is made that the
	 previous delimiter is <u>go</u> <u>to</u> unlessthis is an actual
	 parameter.
</p>

<p class="indent">
	Example:&nbsp;&nbsp;&nbsp; <u>go</u> <u>to</u> S [4] or FUNCTION (S[4],p)
</p>

<p class="indent">
	GTFS or GTS is stacked depending on whether this
	is a formal parameter reference or not, together with
	address in the namelist entry. The current delimiter
	is then stacked.
</p>

<p class="indent">
	If <a href="#DECTYP">DECTYP</a> is set, this delimiter is being used to
	start a bound pair list or to start a subscript expression
	inside a bound pair list.
</p>

<p class="indent">
	Example:&nbsp;&nbsp;&nbsp; <u>array</u> TABLE [1 : LIST [3], 2: n]
</p>

<p class="indent">
	The former case is shown by the fact that the top
	of the stack is <a href="#MAMPS">MAMPS</a> (array map) and <a href="#DECL">DECL</a> is used to
	declare the array name in the namelist. '[' is stacked
	with a dimension count of 1, a marker of 0 to signify
	lower bounds and <a href="#I">I</a> to give the namelist address of the
	arrayname.
</p>

<p class="indent">
	In the latter case, <a href="#E">E</a> is set to expression level
	and <a href="#TAKE">TAKE</a> is used to process the preceding array name,
	before [ is stacked.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<te>
		<td class="noborder">FAIL&nbsp;33&nbsp;&nbsp;;</td>
		<td class="noborder">
			Opening square bracket follows closing bracket.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 73 &nbsp;;</td>
		<td class="noborder">
			Opening square bracket not preceded by
			identifier.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 24 &nbsp;;</td>
		<td class="noborder">
			Switch designator not a parameter or
			preceded by <u>g</u> <u>to</u>
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page85.jpg">[PAGE -82-]</a>
</p>

<p id="RSBRAK" class="center">
	]&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/RSBRAK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_RSBRAK">[Code]</a>
</p>

<p class="indent">
	The preceding expression is completed using <a href="#TAKE">TAKE</a>
	and <a href="#UNSTAK">UNSTAK</a>. The top of the stack then indicates
	whether this is an array or switch subscript expression,
	or an array bound pair list.
</p>

<p class="indent">
	In the former case the top of the stack is [ and
	the <a href="#TYPBOX">TYPBOX</a> is tested to determine whether the subscript
	expression is type <u>integer</u> or <u>real</u>. If <u>real</u>, a
	conversion to <u>integer</u> must be compiled. The values of
	the state variables as at [ are then restored from the
	stack. The number of dimensions counted on the stack
	with [ is checked with the array declaration in the
	<a href="#NAMELIST">namelist</a>. If this is -1 in the namelist (formal
	parameter specifier) the number of dimensions is now
	entered.
</p>

<p class="indent">
	Example:&nbsp;&nbsp;&nbsp;&nbsp; <u>procedure</u> P (b) : <u>array</u> b ;
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A := b[1,3,n] ;
</p>

<p class="indent">
	When the array b is used, it is found that the
	number of dimensions is 3 and can therefore be placed
	in the namelist entry for b.
</p>

<p class="indent">
	If this is a switch subscript, there must be only
	one dimension. Finally, if this is an array subscript,
	INDR is compiled in the case of an expression and IND is
	stacked in the case of a statement since it is not yet
	known if INDA or INDR is required.
</p>

<p class="indent">
	Example:&nbsp;&nbsp;&nbsp;&nbsp; A [2] := B [1, n] := ......
</p>

<p class="indent">
	In the latter case, when this is an array declaration, the number of dimensions is
	placed in <a href="#DIM">DIM</a>, a
	lower/upper bound marker in <a href="#XX">XX</a> and <a href="#I">I</a> is restored
	to the 	array namelist entry. A check is made that the bound
	pair ended with an upper bound (xx = 1), and <a href="#E">E</a> and
	<a href="#ARITH">ARITH</a>
	are set for the following declaration or statement.
</p>

<p class="indent">
	The top of the stack should then be <a href="#MAMPS">MAMPS</a> and this is
	compiled with the number of dimensions and arrays (<a href="#ARRCOU">ARRCOU</a>).
	The namelist entries for each array are then
	updated with the number of dimensions and the address of
	the array map in the object program. Finally, the
	shared map is compiled.
</p>

<p class="indent">
	Example:&nbsp;&nbsp;&nbsp;&nbsp; array A,B,C [p;q, s:t]
</p>

<p class="indent">
	<a href="#ARRCOU">ARRCOU</a> will be 3 and number of dimensions will be 2.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;74&nbsp;&nbsp;;</td>
		<td class="noborder">unmatched closing square bracket.
	</tr>
	<tr>
		<td class="noborder">FAIL 51 &nbsp;;</td>
		<td class="noborder">wrong number of dimensions in array subscript</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 95 &nbsp;;</td>
		<td class="noborder">more than one dimension in switch subscript</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 75 &nbsp;;</td>
		<td class="noborder">upper bound missing from bound pair</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 23 &nbsp;;</td>
		<td class="noborder">correct array declaration.
	</tr>
</table>

<p>
	<a href="Description Pages/page86.jpg">[PAGE -83-]</a>
</p>


<p id="COLON" class="center">

	:&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/COLON.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_COLON">[Code]</a>
</p>

<p class="indent">
	<a href="#DECTYP">DECTYP</a> is used to decide whether the current
	identifier follows a label or a lower bound in an array
	declaration.
</p>

<p class="indent">
	in the latter case, <a href="#ARRBND">ARRBND</a> processes the current
	ALGOL section.
</p>

<p class="indent">
	In the former case, <a href="#EXP">EXP</a> is used to check the
	validity of the use of the label, and <a href="#DECSTA">DECSTA</a> is set to
	statement level (as one cannot label a declaration without
	an intervening begin), The <a href="#NAMELIST">Name List</a> is then searched
	for the label (which must have been declared in a prior
	switch list declaration), and the label entry in <a href="#CODL">Label
	Object Data Load (CODL)</a> should have an address part of
	zero. If not, this label has been met on the left-hand
	side of a colon twice and this is an error.
</p>

<p class="indent">
	The next test is to see whether this label has been
	declared in the current block, If it hasn't, it is an
	error except in the case of procedure definitions or for
	clauses (see example below). In these cases, the
	existing entry in <a href="#CODL">CODL</a> is cleared and a new entry made.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder">
	<tr>
		<td class="noborder">FAIL&nbsp;29;</td>
		<td class="noborder">: in type or switch declaration.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;9;</td>
		<td class="noborder">label used twice on left-hand side.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 48;</td>
		<td class="noborder">misused identifier.</td>
	</tr>
</table>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">Example:</td>
		<td class="noborder">
			<pre class="courier">
<u>begin</u> <u>real</u> c; <u>switch</u> S:= LABEL;
<u>procedure</u> <a href="#P">P</a> (q,r,s); <u>integer</u> q,r,s;
LABEL: </u>begin</u> q := r+s;
       <u>go</u> <u>to</u> LABEL
<u>end</u>;
</pre>
		</td>
	</tr>
</table>

<p class="indent">
	If the first <u>begin</u> sets the block number to (say)
	52, LABEL is entered by its declaration in Block 52.
	But <u>procedure</u> <a href="#P">P</a> resets the block number to 53, and when
	LABEL is met on the left-hand side, the block numbers do
	not correspond.
</p>

<p>
	<a href="Description Pages/page87.jpg">[PAGE -84-]</a>
</p>


<p id="COMMA" class="center">
	,&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/COMMA.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_COMMA">[Code]</a>
</p>

<p class="indent">
	This routine deals with various uses of the
	delimiter , .
</p>


<table class="noborder">
	<tr>
		<td class="noborder">i)</td>
		<td class="noborder">
			<a href="#INOUT">INOUT</a> (1)
			is called to deal with a read or print list comma.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">ii)</td>
		<td class="noborder">
			If we are in a procedure call (PROC = 1)
			the subroutine <a href="#ACTOP">ACTOP</a> is used to process
			the current ALGOL section.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">iii)</td>
		<td class="noborder">
			If the for clause marker is set, the
			subroutine <a href="#FORCOM">FORCOM</a> is used to distinguish
			between the use of comma between for list
			elements in which case PRIM DO is compiled
			after a typecheck, or between subscript
			expressions of a variable used in a for
			list element. The latter case does not
			return from <a href="#FORCOM">FORCOM</a>.
		<br><br>
			The former case then stacks the simple for
			element again, sets the state variable <a href="#ARITH">ARITH</a>
			to 1 and exits.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">iv)</td>
		<td class="noborder">If <a href="#DECTYP">DECTYP</a> = <a href="#O">O</a>
			the current delimiter is
			being used between subscript expressions,
			and is processed by the subroutine <a href="#ARRBND">ARRBND</a>.
			<br><br>
		</td>
	</tr>
	<tr>
		<td class="noborder">v)</td>
		<td class="noborder">
			Finally, the top of the stack is used to
			differentiate between various uses of a
			comma in an array declaration.
			<br><br>
			If the top of the stack is <a href="#MAMPS">MAMPS</a>, the comma
			is between array identifiers viz:
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			<u>real</u> <u>array</u> A, B, ....
			<br><br>
			and the identifier is entered in the <a href="#NAMELIST">Name
			List</a> using <a href="#DECL">DECL</a>.
			<br><br>
			Otherwise the comma is being used between
			subscript expressions, and <a href="#ARRBND">ARRBND</a> processes
			the current ALGOL section.
		</td>
	</tr>
</table>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;96;</td>
		<td class="noborder">incorrect for clause (FORCOM)</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 77;</td>
		<td class="noborder">
			incorrect use of comma, or missing identifier
			in array declaration.
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page88.jpg">[PAGE -85-]</a>
</p>

<p id="LRBRAK" class="center">
	(&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/LRBRAK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_LRBRAK">[Code]</a>
</p>

<p class="indent">
	After the initial checks to catch subscripted
	constants and ( immediately following a closing bracket
	<a href="#DECTYP">DECTYP</a> is tested to see whether we are in array
	declaration or in a statenent. The state variable <a href="#M">M</a> will
	tell us whether this delimiter is being used as an expression
	bracket or in a procedure call.
</p>

<p class="indent">
	In the case of an array declaration, a failure is
	indicated if <a href="#E">E</a> is set to statement level, unless
	<a href="#PROC">PROC</a>
	shows that an actual parameter is being processed, e.g.
</p>

<p class="margin1">
	<u>real</u> <u>array</u> A [1: PROC (a, PROC2(....
	<br>
	or <u>real</u> <u>array</u> A (4: PROC (a, (b + c ....
</p>

<p class="indent">
	The former example will cause <a href="#M">M</a> to be set at 1, and
	the latter zero, which is the subject of the next test.
	Where this is a procedure call, the flowchart joins with
	the path where <a href="#DECTYP">DECTYP</a> was zero and this was a procedure
	call (which has already called <a href="#EXP">EXP</a> to change
	<a href="#I">I</a> to
	expression level if necessary, and set <a href="#EXPRES">EXPRES</a> in the
	case of a read or print statement e.g. <u>read</u> reader (1)...)
</p>

<p class="indent">
	The case of "<u>go</u> <u>to</u> <a href="#S">S</a> (..." is failed by the next
	test on EXPTYP; and the procedure name is then searched
	for in the <a href="#NAMELIST">Name List</a>. If we are in an array
	declaration,
	we check that the array bounds are not local (illegal
	ALGOL), before discovering whether this is a type
	procedure, If so, space is reserved on the run-time
	stack (by compiling PRIM UP) for the result of the type
	procedure, Various variables are then stacked with the
	delimiter, and these variables are then set up to deal
	with the actual parameters of this procedure call.
</p>

<p class="indent">
	In the case of expression brackets used in
	statements, the delimiter is stacked, and <a href="#PROC">PROC</a> set to
	zero while processing the constituents of the bracket.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;61&nbsp;&nbsp;;</td>
		<td class="noborder">( misplaced</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 82 &nbsp;;</td>
		<td class="noborder">( must not appear in a type declaration</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 62 &nbsp;;</td>
		<td class="noborder">
			function designator as subject of "go to"
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 41 &nbsp;;</td>
		<td class="noborder">array bounds must not be local</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 25 &nbsp;;</td>
		<td class="noborder">
			non type procedure as function designator in expression
		</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page89.jpg">[PAGE -86-]</a>
</p>


<p id="RRBRAK" class="center">
	)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/RRBRAK_STRENT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_RRBRAK">[Code]</a>
</p>

<p class="indent">
	The state variable <ahref="#PROC">PROC</a> indicates whether this
	delimiter is an expression bracket or a procedure call
	bracket.
</p>

<p class="indent">
	If it is an expression bracket, we first check
	that we are in fact within an expression. This kills
	"a + (b)". The translation of the preceding
	expression is completed using <a href="#TAKE">TAKE</a>
	and <a href="#UNSTAK">UNSTAK</a>, after
	which the top of the stack should be the delimiter (.
	This is unstacked and discarded, having reset
	<a href="#PROC">PROC</a> to
	the stacked value.
</p>

<p class="indent">
	If it is a procedure call bracket, <a href="#ACTOP">ACTOP</a> is called
	to complete the translation of the preceding parameter,
	<a href="#PROCPO">PROCPO</a> is saved in <a href="#I">I</a>
	after the top-of-stack test, and
	the stacked state variables restored. A test is now
	made to see whether the count of parameters in the call
	is equal to that in the declaration; if not, it may be
	that this procedure is itself a formal parameter. If so,
	the specifier in question has not told us how many
	parameters are required, and we must fill the count in
	from this call. However, we must first check that this
	count has not been filled in by some previous use, if so
	it must fail as in the last line of the following example.
</p>

<p class="margin1">
	<u>real</u> <u>procedure</u> JIM (a,b); <u>integer</u> a ; <u>real</u>
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<u>procedure</u> b;
	<br>
	<u>begin</u> <u>integer</u> q,r,s;
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b (a,r,s);
	<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b(q,r);</p>

	<p class="indent">
	The test on f [I] determines what sort of
	instruction to compile for this procedure call. Finally,
	if <a href="#E">E</a> is set to statement level a check is made that the
	next delimiter is an "end-of-statement" delimiter,
	otherwise in the expression case <a href="#TYPBOX">TYPBOX</a> must be set.
</p>

<p>
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;&nbsp;81;</td>
		<td class="noborder">misused ) other than in expression.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;82;</td>
		<td class="noborder">unmatched closing round bracket.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;&nbsp;5;</td>
		<td class="noborder">illegal parameter list.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;51;</td>
		<td class="noborder">incorrect number of parameters.</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 111;</td>
		<td class="noborder">
			incorrect number of parameters in
			use of formal procedure.
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL &nbsp;84;</td>
		<td class="noborder">wrong delimiter after procedure statement.</td>
	</tr>
</table>

<p>
	<a href="Description Pages/page90.jpg">[PAGE -87-]</a>
</p>


<p id="QUOTE" class="center">
	{ (string opening quote)&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/QUOTE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_QUOTE">[Code]</a>
</p>

<p class="indent">
	This routine checks that this string is being
	used as an actual parameter, or in a print statement,
	and then compiles an unconditional jump around the
	string, which will be updated when the last character
	in the string is read. There is a count of nested
	string quotes, and the characters are packed for the
	object program. When the final closing string quote
	is read, the UJ operation is updated and '}' is stored
	as the last delimiter. If a parameter case the following
	call to <a href="#BCR">BCR</a> should fetch ' ,' or ')', and
	<a href="#ACTOP">ACTOP</a> is then
	called. If a print statenent <a href="#INOUT">INOUT</a> is compiled, and
	the delimiter which may be <u>end</u> or <u>else</u> also decides the
	following action.
</p>

<p class="indent">
	Example&nbsp;&nbsp;&nbsp;&nbsp;PROCALL (a, {string}, {otherstring})
</p>

<p class="insert">
	After compiling the actual operation for the string,
	<a href="#ACTOP">ACTOP</a> is used to check that the corresponding formal
	parameter is specified as string called by name. <a href="#E">E</a> is
	set to statement level and if the current delimiter is
	')' exit from this routine is to ) entry 2 to complete
	the processing of the procedure call.
</p>

<p class="indent">
	<u>ERRORS</u>
</p>

<table class="noborder margin1t">
	<tr>
		<td class="noborder">FAIL&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;;</td>
		<td class="noborder">
			string is not the complete actual parameter
		</td>
	</tr>
	<tr>
		<td class="noborder">FAIL 105 &nbsp;;</td>
		<td class="noborder">wrong delimiter following string.</td>
	</tr>
</table>
</pre>

<br><br><hr>

<p class="indent red">
	There are more subroutines / entry points in the source of the Translator
	than described in the preceding description.  Here is a list with links to
	the Flowchart and corresponding code.
</p>

<p id="ADJI">
	ADJI:&nbsp;&nbsp;
	<a href="file:Flowcharts/ADJI.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ADJI">[Code]</a>
</p>

<p id="ARRBND">
	ARRBND:
	<a href="file:Flowcharts/ARRBND.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ARRBND">[Code]</a>
</p>

<p id="ARENT2">
	ARENT2:
	<a href="file:Flowcharts/ARRAY_ARENT2.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#ARENT2">[Code]</a>
</p>

<p id="BLANKS">
	BLANKS:
	<a href="file:Flowcharts/PUNGRP_PUNCHA_BLANKS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_BLANKS">[Code]</a>
</p>

<p id="CHECK">
	CHECK:&nbsp;
	<a href="file:Flowcharts/CHECK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_CHECK">[Code]</a>
</p>

<p id="CHKINO">
	CHECK:&nbsp;
	<a href="file:Flowcharts/CODE_READ_PRINT_CHKINO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_CHKINO">[Code]</a>
</p>

<p id="CODE">
	CODE:&nbsp;&nbsp;
	<a href="file:Flowcharts/CODE_READ_PRINT_CHKINO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_CODE">[Code]</a>
</p>

<p id="COMP">
	COMP:&nbsp;&nbsp;
	<a href="file:Flowcharts/COMP_COMP2.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_COMP">[Code]</a>
</p>

<p id="COMP2">
	COMP2:&nbsp;
	<a href="file:Flowcharts/COMP_COMP2.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_COMP2">[Code]</a>
</p>

<p id="COMPIL">
	COMPIL:
	<a href="file:Flowcharts/COMPIL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_COMPIL">[Code]</a>
</p>

<p id="ENDPRO">
	ENDPRO:
	<a href="file:Flowcharts/ENDPRO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_ENDPRO">[Code]</a>
</p>

<p id="ENT2">
	ENDPRO:
	<a href="file:Flowcharts/END.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_END">[Code]</a>
</p>

<p id="FOMCOM">
	FOMCOM:
	<a href="file:Flowcharts/FOMCOM.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FOMCOM">[Code]</a>
</p>


<p id="FILBUF">
	FILBUF:
	[No f]lowchart]</a>
	<a href="file:Translator_source.htm#G_FILBUF">[Code]</a>
</p>


<p id="FOMPIL">
	RESTO:&nbsp;
	<a href="file:Flowcharts/FOMPIL.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_FOMPIL">[Code]</a>
</p>

<p id="GETCHA">
	GETCHA:
	<a href="file:Flowcharts/GETCHA.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_GETCHA">[Code]</a>
</p>

<p id="INOUT">
	INOUT:&nbsp;
	<a href="file:Flowcharts/INOUT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_INOUT">[Code]</a>
</p>

<p id="LINO">
	LINO:&nbsp;&nbsp;
	<a href="file:Flowcharts/LINO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_LINO">[Code]</a>
</p>

<p id="LISTAD">
	LISTAD:
	<a href="file:Flowcharts/LISTAD_PCHAR.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_LISTAD">[Code]</a>
</p>

<p id="MIDTRM">
	MIDTRM:
	<a href="file:Flowcharts/STATRM_MIDTRM.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_MIDTRM">[Code]</a>
</p>

<p id="OUT">
	OUT:&nbsp;&nbsp;&nbsp;
	<a href="file:Flowcharts/OUT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_OUT">[Code]</a>
</p>

<p id="OUT2">
	OUT2:&nbsp;&nbsp;
	<a href="file:Flowcharts/OUT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_OUT2">[Code]</a>
</p>
<p id="PCHAR">
	PCHAR:&nbsp;
	<a href="file:Flowcharts/LISTAD_PCHAR.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PCHAR">[Code]</a>
</p>

<p id="POWER">
	POWER:&nbsp;
	<a href="file:Flowcharts/POWER.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_POWER">[Code]</a>
</p>

<p id="PRESTO">
	PRESTO:
	<a href="file:Flowcharts/PRESTO_RESTO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PRESTO">[Code]</a>
</p>

<p id="PRINT">
	PRINT:&nbsp;
	<a href="file:Flowcharts/CODE_READ_PRINT_CHKINO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PRINT">[Code]</a>
</p>

<p id="PUNGLB">
	PUNGLB:
	[No flowchart]
	<a href="file:Translator_source.htm#G_RESTO">[Code]</a>
</p>

<p id="PUNGRP">
	PUNGRP:
	<a href="file:Flowcharts/PUNGRP_PUNCHA_BLANKS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PUNGRP">[Code]</a>
</p>

<p id="PUNCHA">
	PUNCHA:
	<a href="file:Flowcharts/PUNGRP_PUNCHA_BLANKS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_PUNCHA">[Code]</a>
</p>

<p id="READ">
	READ:&nbsp;&nbsp;
	<a href="file:Flowcharts/CODE_READ_PRINT_CHKINO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_READ">[Code]</a>
</p>

<p id="REPORT">
	READ:&nbsp;&nbsp;
	<a href="file:Flowcharts/REPORT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_REPORT">[Code]</a>
</p>

<p id="RESTO">
	RESTO:&nbsp;
	<a href="file:Flowcharts/PRESTO_RESTO.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_RESTO">[Code]</a>
</p>

<p id="STACK">
	STACK:&nbsp;
	<a href="file:Flowcharts/STACK.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_STACK">[Code]</a>
</p>

<p id="STAND">
	READ:&nbsp;&nbsp;
	<a href="file:Flowcharts/STAND.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_STAND">[Code]</a>
</p>

<p id="START">
	START:&nbsp;
	<a href="file:Flowcharts/START.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_START">[Code]</a>
</p>


<p id="STATRM">
	STATRM:
	<a href="file:Flowcharts/STATRM_MIDTRM.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_STATRM">[Code]</a>
</p>

<p id="STRENT">
	STRENT:
	<a href="file:Flowcharts/RRBRAK_STRENT.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#G_STRENT">[Code]</a>
</p>


<p id="TAKCHA">
	TAKCHA:
	<a href="file:Flowcharts/TAKCH.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#TAKCHA">[Code]</a>
</p>


<p id="TITLE">
	TITLE:&nbsp;
	<a href="file:Flowcharts/TITLE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#TITLE">[Code]</a>
</p>

<p id="UPDATE">
	UPDATE:
	<a href="file:Flowcharts/UPDATE.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#UPDATE">[Code]</a>
</p>


<p id="WMESS">
	WMESS:&nbsp;
	<a href="file:Flowcharts/WMESS.pdf">[Flowchart]</a>
	<a href="file:Translator_source.htm#WMESS">[Code]</a>
</p>

</body>
</html>

